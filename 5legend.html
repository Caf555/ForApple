<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‹‡è€…å‚³èªªï¼šäº”åŸŸå¾é€” - å¢å¼·ç‰ˆ</title>
    <meta name="description" content="å°ˆç‚ºæ‰‹æ©Ÿå„ªåŒ–çš„æ–‡å­—å†’éšªRPGéŠæˆ² - åŒ…å«æ‰€æœ‰AIç”Ÿæˆåœ–ç‰‡ã€å®Œæ•´çš„è£å‚™èˆ‡æŠ€èƒ½ç³»çµ±ã€‚">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 50%, #312e81 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
            font-size: 14px;
        }

        .game-card {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .btn {
            border: none;
            color: white;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            touch-action: manipulation;
            padding: 0.5rem 1rem;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(50%);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-primary { background: linear-gradient(45deg, #dc2626, #ef4444); }
        .btn-secondary { background: linear-gradient(45deg, #2563eb, #3b82f6); }
        .btn-success { background: linear-gradient(45deg, #16a34a, #22c55e); }
        .btn-purple { background: linear-gradient(45deg, #7c3aed, #8b5cf6); }
        .btn-warning { background: linear-gradient(45deg, #d97706, #f59e0b); }

        .health-bar, .mp-bar, .exp-bar {
            transition: width 0.5s ease-in-out;
        }

        @keyframes fadeUp {
            0% { opacity: 1; transform: translateY(0px); }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes slideIn {
            0% { transform: translateX(-100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }

        @keyframes gentleBreathing {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.005); filter: brightness(1.02); }
        }

        @keyframes combatShake {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.02) rotate(0.5deg); }
            75% { transform: scale(0.98) rotate(-0.5deg); }
        }

        @keyframes statusEffect {
            0%, 100% { box-shadow: 0 0 5px rgba(124, 58, 237, 0.5); }
            50% { box-shadow: 0 0 15px rgba(124, 58, 237, 0.8); }
        }

        .combat-animation {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: fadeUp 2s ease-out forwards;
            z-index: 1000;
        }

        .status-effect-active {
            animation: statusEffect 2s ease-in-out infinite;
        }

        /* åœ–ç‰‡æ¡†æ¨£å¼ */
        .image-container {
            width: 100%;
            height: 200px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin-bottom: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #64748b;
            background: radial-gradient(circle at center, rgba(59, 130, 246, 0.1) 0%, transparent 70%);
        }

        .image-placeholder-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            opacity: 0.7;
        }
        
        .image-gentle-transition {
            animation: gentleBreathing 4s ease-in-out infinite;
        }

        .image-combat-shake {
            animation: combatShake 0.6s ease-in-out;
        }

        /* æ‰‹æ©Ÿå„ªåŒ–å¸ƒå±€ */
        .mobile-layout {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 0.5rem;
            gap: 0.75rem;
        }

        .top-panel { flex-shrink: 0; }
        .main-game-area { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            min-height: 0; 
        }
        .bottom-panel { flex-shrink: 0; max-height: 40vh; overflow-y: auto; }

        /* å›ºå®šæŒ‰éˆ•å€åŸŸ */
        .game-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .game-display {
            flex: 1;
            min-height: 0;
        }

        .fixed-action-area {
            flex-shrink: 0;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* æˆ°é¬¥ç•Œé¢ç‰¹æ®Šå¸ƒå±€ */
        .battle-container { 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
        }
        .battle-info { flex-shrink: 0; }
        .battle-log { 
            flex: 1; 
            min-height: 80px; 
            overflow-y: auto; 
            margin: 0.5rem 0; 
        }

        /* æ¨™ç±¤é ç³»çµ± */
        .tab-bar { 
            display: flex; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.2); 
        }
        .tab-button { 
            flex: 1; 
            padding: 0.75rem; 
            text-align: center; 
            cursor: pointer; 
            border-bottom: 2px solid transparent; 
            transition: all 0.3s ease; 
            font-size: 0.8rem; 
        }
        .tab-button.active { 
            border-bottom-color: #3b82f6; 
            background: rgba(59, 130, 246, 0.1); 
            font-weight: bold; 
        }
        .tab-content { 
            padding: 0.75rem; 
            animation: fadeIn 0.3s; 
            min-height: 150px; 
            max-height: 250px; 
            overflow-y: auto; 
        }

        /* ç·Šæ¹Šçš„æ—¥èªŒæ¨£å¼ */
        .compact-log { 
            height: 100%; 
            overflow-y: auto; 
            background: rgba(0, 0, 0, 0.3); 
            border-radius: 8px; 
            padding: 0.25rem; 
            border: 1px solid rgba(255, 255, 255, 0.1); 
        }
        .log-entry { 
            font-size: 0.75rem; 
            padding: 0.25rem; 
            margin-bottom: 0.2rem; 
            border-radius: 4px; 
            line-height: 1.2; 
            border-left: 3px solid transparent; 
        }
        .log-entry:first-child { border-left-color: #10b981; }

        /* é€²åº¦æ¢å„ªåŒ– */
        .progress-container { 
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
            margin-bottom: 0.5rem; 
        }
        .progress-bar { 
            flex: 1; 
            height: 8px; 
            background: #374151; 
            border-radius: 4px; 
            overflow: hidden; 
        }
        .progress-fill { 
            height: 100%; 
            transition: width 0.5s ease; 
            border-radius: 4px; 
        }

        /* å¿«é€Ÿè¡Œå‹•åˆ— */
        .quick-actions { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 0.5rem; 
            justify-content: center; 
        }
        .quick-action-btn { 
            flex: 1; 
            min-width: 70px; 
            max-width: 120px; 
            padding: 0.75rem 0.5rem; 
            font-size: 0.75rem; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            gap: 0.25rem; 
            text-align: center; 
            line-height: 1.2; 
            min-height: 65px; 
        }
        .quick-action-btn span:first-child { 
            font-size: 1rem; 
            margin-bottom: 0.25rem; 
        }

        /* è£å‚™è¦–è¦ºåŒ– */
        .equipment-visual { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 0.5rem; 
        }
        .equipment-slot { 
            background: rgba(0, 0, 0, 0.3); 
            border: 2px dashed rgba(255, 255, 255, 0.2); 
            border-radius: 8px; 
            padding: 0.5rem; 
            text-align: center; 
            transition: all 0.3s ease; 
            min-height: 60px; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
        }
        .equipment-slot.equipped { 
            background: rgba(59, 130, 246, 0.1); 
            border-color: #3b82f6; 
            border-style: solid; 
        }
        .equipment-slot-icon { 
            font-size: 1.2rem; 
            margin-bottom: 0.25rem; 
        }
        .equipment-slot-name { 
            font-size: 0.6rem; 
            color: #9ca3af; 
            word-break: break-all; 
        }

        /* èƒŒåŒ…å’ŒæŠ€èƒ½é¢æ¿æ¨£å¼ */
        .inventory-item, .skill-item { 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 0.5rem; 
            margin-bottom: 0.5rem; 
            background: rgba(255, 255, 255, 0.05); 
            border-radius: 6px; 
        }
        .item-info, .skill-info { flex: 1; }
        .item-name, .skill-name { 
            font-weight: bold; 
            font-size: 0.9rem; 
        }
        .item-stats, .skill-desc { 
            font-size: 0.7rem; 
            color: #9ca3af; 
            margin-top: 0.2rem; 
        }
        .item-actions, .skill-actions { 
            display: flex; 
            gap: 0.5rem; 
        }
        .item-actions .btn, .skill-actions .btn { 
            font-size: 0.7rem; 
            padding: 0.25rem 0.5rem; 
        }

        /* ç‹€æ…‹æ•ˆæœé¡¯ç¤º */
        .status-effects {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .status-effect {
            background: rgba(124, 58, 237, 0.3);
            border: 1px solid #7c3aed;
            border-radius: 12px;
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        /* éŸ¿æ‡‰å¼ç¶²æ ¼ - é›»è…¦ç‰ˆå„ªåŒ– */
        @media (min-width: 768px) {
            .mobile-layout { 
                display: grid; 
                grid-template-columns: 350px 1fr 300px; 
                grid-template-rows: auto 1fr; 
                gap: 1rem; 
                padding: 1rem; 
                max-width: 1400px; 
                margin: 0 auto; 
            }
            .top-panel { grid-column: 1; grid-row: 1 / -1; }
            .main-game-area { grid-column: 2; grid-row: 1 / -1; }
            .bottom-panel { grid-column: 3; grid-row: 1 / -1; max-height: none; }
            .image-container { height: 250px; }
            .tab-content { max-height: calc(100vh - 100px); }
        }
    </style>
</head>
<body>
    <div id="root">
        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; font-size: 1.2rem;">
            âš”ï¸ æ­£åœ¨è¼‰å…¥å‹‡è€…å‚³èªª...
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;
        
        const AdventureGame = () => {
            // --- STATE MANAGEMENT ---
            const [gameState, setGameState] = useState('menu');
            const [selectedClass, setSelectedClass] = useState(null);
            const [currentImage, setCurrentImage] = useState({ prompt: '', title: '', imageUrl: '' });
            const [isLoading, setIsLoading] = useState(true);
            const [isPlayerTurn, setIsPlayerTurn] = useState(true);
            const [activeTab, setActiveTab] = useState('inventory');
            const [name, setName] = useState('');
            
            // é è¨­åœ–ç‰‡åº«
            const defaultImageUrls = { "menu": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/éŠæˆ²é–‹å§‹ç•«é¢.jpg", "exploration": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/å‹‡æ•¢æ¢ç´¢.jpg", "combat": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/æ¿€çƒˆæˆ°é¬¥.jpg", "levelUp": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/ç­‰ç´šæå‡.jpg", "treasureFound": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/ç™¼ç¾å¯¶è—.jpg", "goldCoins": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/ç™¼ç¾é‡‘å¹£.jpg", "victory": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/å‡±æ—‹.jpg", "gameOver": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/è‹±é›„éš•è½.jpg", "warrior": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/æˆ°å£«è·æ¥­.jpg", "mage": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/æ³•å¸«.jpg", "rogue": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/ç›œè³Š.jpg", "forest": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/æ£®æ—.jpg", "mountain": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/è’¼ç©¹å±±è„ˆ.jpg", "desert": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/ç„¦ç†±æ²™æ¼ .jpg", "icefield": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/æ¥µå‡å†°åŸ.jpg", "volcano": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/åœ°ç„ç«å±±.jpg", "demonKing": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/æ¯€æ»…é­”ç‹.jpg", "forestWolf": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/æ£®æ—ç‹¼.jpg", "corruptedTreespirit": "https://raw.githubusercontent.com/Caf555/ForApple/d1640533d2a08f16bc7d1ced7101e4f6798c2f07/RPG%20JPG/è…åŒ–æ¨¹ç²¾.jpg", "forestGuardian": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/æ£®æ—å®ˆè­·è€….jpg", "mountainKing": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/å±±è„ˆä¹‹ç‹.jpg", "desertOverlord": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/æ²™æ¼ éœ¸ä¸».jpg", "frostQueen": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/å†°éœœå¥³ç‹.jpg", "fireLord": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/ç«ç„°é ˜ä¸».jpg", "healthPotion": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/ç”Ÿå‘½è—¥æ°´.jpg", "forestSword": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/æ£®æ—ä¹‹åŠ.jpg", "holyBlade": "https://raw.githubusercontent.com/Caf555/ForApple/124c96adbdf8ffcb8787899adf64176ad8dbd879/RPG%20JPG/è–å…‰åŠ.jpg" };
            const [uploadedImages, setUploadedImages] = useState(defaultImageUrls);

            const [player, setPlayer] = useState(null);
            const [battleState, setBattleState] = useState(null);
            const [gameLog, setGameLog] = useState([]);
            const [currentAreaIndex, setCurrentAreaIndex] = useState(0);
            const [combatAnimations, setCombatAnimations] = useState([]);

            // --- HELPER FUNCTIONS ---
            const addLog = useCallback((message, type = "normal") => {
                setGameLog(prev => [{ message, type, timestamp: new Date().toLocaleTimeString() }, ...prev.slice(0, 49)]);
            }, []);
            
            const addCombatAnimation = useCallback((text, type = "damage") => {
                const id = Date.now() + Math.random();
                setCombatAnimations(prev => [...prev, { id, text, type }]);
                setTimeout(() => setCombatAnimations(prev => prev.filter(anim => anim.id !== id)), 2000);
            }, []);

            const setImage = useCallback((imageKey) => {
                setCurrentImage({ imageUrl: uploadedImages[imageKey] || '' });
            }, [uploadedImages]);

            // æ›´æ–°ç©å®¶çµ±è¨ˆæ•¸æ“š
            const updatePlayerStats = useCallback((statType, value = 1) => {
                setPlayer(prev => ({
                    ...prev,
                    stats: {
                        ...prev.stats,
                        [statType]: (prev.stats[statType] || 0) + value
                    }
                }));
            }, []);

            // æ‡‰ç”¨ç‹€æ…‹æ•ˆæœ
            const applyStatusEffect = useCallback((effect) => {
                setPlayer(prev => {
                    const newStatusEffects = [...prev.statusEffects];
                    const existingIndex = newStatusEffects.findIndex(e => e.type === effect.type);
                    
                    if (existingIndex >= 0) {
                        newStatusEffects[existingIndex] = effect;
                    } else {
                        newStatusEffects.push(effect);
                    }
                    
                    return { ...prev, statusEffects: newStatusEffects };
                });
            }, []);

            // è™•ç†ç‹€æ…‹æ•ˆæœæŒçºŒæ™‚é–“
            const processStatusEffects = useCallback(() => {
                setPlayer(prev => {
                    const newStatusEffects = prev.statusEffects
                        .map(effect => ({ ...effect, duration: effect.duration - 1 }))
                        .filter(effect => effect.duration > 0);
                    
                    return { ...prev, statusEffects: newStatusEffects };
                });
            }, []);

            // --- GAME DATA ---
            const itemDatabase = {
                1: { id: 1, name: "ç”Ÿå‘½è—¥æ°´", type: "potion", heal: 60, value: 20, imageKey: "healthPotion" },
                2: { id: 2, name: "é­”åŠ›è—¥æ°´", type: "potion", mp: 40, value: 25 },
                3: { id: 3, name: "å…¨å¾©è—¥æ°´", type: "potion", heal: 100, mp: 70, value: 50 },
                101: { id: 101, name: "çŸ­åŠ", type: "weapon", attack: 5, value: 30 },
                102: { id: 102, name: "æ£®æ—ä¹‹åŠ", type: "weapon", attack: 8, value: 50, imageKey: "forestSword" },
                103: { id: 103, name: "å±±è„ˆä¹‹æ–§", type: "weapon", attack: 12, value: 150 },
                104: { id: 104, name: "è–å…‰åŠ", type: "weapon", attack: 25, value: 300, imageKey: "holyBlade" },
                201: { id: 201, name: "çš®ç”²", type: "armor", defense: 5, value: 40 },
                202: { id: 202, name: "é±—ç”²", type: "armor", defense: 12, value: 80 },
                203: { id: 203, name: "ç†¾å¤©ä½¿è­·ç”²", type: "armor", defense: 25, value: 250 },
                301: { id: 301, name: "é€Ÿåº¦ä¹‹é´", type: "accessory", speed: 5, value: 100 },
            };

            const classes = {
                warrior: { name: "æˆ°å£«", emoji: "âš”ï¸", description: "è¿‘æˆ°å°ˆå®¶ï¼Œé«˜æ”»æ“Šå’Œé˜²ç¦¦åŠ›", bonuses: { attack: 10, defense: 8, hp: 30, mp: 0, speed: 0, luck: 0 }, skills: ["é‡æ“Š", "é˜²ç¦¦å§¿æ…‹"] },
                mage: { name: "æ³•å¸«", emoji: "ğŸ”®", description: "é­”æ³•ä½¿ç”¨è€…ï¼Œé«˜é­”åŠ›å’ŒæŠ€èƒ½å‚·å®³", bonuses: { attack: 5, defense: 3, hp: 0, mp: 30, speed: 0, luck: 5 }, skills: ["ç«çƒè¡“", "æ²»ç™‚è¡“"] },
                rogue: { name: "ç›œè³Š", emoji: "ğŸ—¡ï¸", description: "æ•æ·åˆºå®¢ï¼Œé«˜æš´æ“Šå’Œé€Ÿåº¦", bonuses: { attack: 8, defense: 0, hp: 0, mp: 0, speed: 10, luck: 8 }, skills: ["èƒŒåˆº", "æ¯’åˆƒ"] }
            };

            const skillDatabase = {
                "é‡æ“Š": { name: "é‡æ“Š", mp: 10, power: 1.8, type: "damage", desc: "é€ æˆ180%ç‰©ç†å‚·å®³", level: 1 },
                "é˜²ç¦¦å§¿æ…‹": { name: "é˜²ç¦¦å§¿æ…‹", mp: 10, type: "buff", effect: { type: "defense_boost", value: 2, duration: 3 }, desc: "3å›åˆå…§é˜²ç¦¦åŠ›åŠ å€", level: 1 },
                "æˆ°å¼": { name: "æˆ°å¼", mp: 15, type: "buff", effect: { type: "attack_boost", value: 1.5, duration: 3 }, desc: "3å›åˆå…§æ”»æ“Šæå‡50%", unlockLevel: 5 },
                "ç«çƒè¡“": { name: "ç«çƒè¡“", mp: 12, power: 2.0, type: "damage", desc: "é€ æˆ200%é­”æ³•å‚·å®³", level: 1 },
                "æ²»ç™‚è¡“": { name: "æ²»ç™‚è¡“", mp: 15, power: 0.5, type: "heal", desc: "æ¢å¾©50%æœ€å¤§ç”Ÿå‘½", level: 1 },
                "é­”æ³•è­·ç›¾": { name: "é­”æ³•è­·ç›¾", mp: 20, type: "buff", effect: { type: "shield", value: 50, duration: 5 }, desc: "ç”¢ç”Ÿä¸€å€‹50é»çš„è­·ç›¾ï¼ŒæŒçºŒ5å›åˆ", unlockLevel: 5 },
                "èƒŒåˆº": { name: "èƒŒåˆº", mp: 10, power: 1.5, critChance: 0.5, type: "damage", desc: "é«˜æš´æ“Šç‡çš„æ”»æ“Š", level: 1 },
                "æ¯’åˆƒ": { name: "æ¯’åˆƒ", mp: 12, type: "debuff", effect: { type: "poison", damage: 10, duration: 3 }, desc: "ä½¿æ•µäººä¸­æ¯’3å›åˆ", level: 1 },
                "é–ƒé¿": { name: "é–ƒé¿", mp: 15, type: "buff", effect: { type: "dodge_boost", value: 0.5, duration: 2 }, desc: "2å›åˆå…§é–ƒé¿ç‡æå‡50%", unlockLevel: 5 },
            };

            const areas = [
                { 
                    name: "è¿·éœ§æ£®æ—", imageKey: "forest", 
                    enemies: [ 
                        { name: "æ£®æ—ç‹¼", hp: 60, attack: 18, defense: 5, exp: 25, gold: 15, imageKey: "forestWolf", drops: [{itemId: 1, chance: 0.3}, {itemId: 101, chance: 0.1}] },
                        { name: "è…åŒ–æ¨¹ç²¾", hp: 90, attack: 15, defense: 12, exp: 35, gold: 20, imageKey: "corruptedTreespirit", drops: [{itemId: 201, chance: 0.15}] }
                    ], 
                    boss: { name: "æ£®æ—å®ˆè­·è€…", hp: 200, attack: 25, defense: 15, exp: 100, gold: 80, imageKey: "forestGuardian", drops: [{itemId: 102, chance: 1}] }, 
                    treasures: [1, 101, 201] 
                },
                { 
                    name: "è’¼ç©¹å±±è„ˆ", imageKey: "mountain", 
                    enemies: [ 
                        { name: "çŸ³å·¨äºº", hp: 120, attack: 28, defense: 20, exp: 45, gold: 25, drops: [{itemId: 2, chance: 0.2}] },
                        { name: "é¢¨æš´é·¹", hp: 100, attack: 30, defense: 10, exp: 40, gold: 30, drops: [{itemId: 301, chance: 0.1}] }
                    ], 
                    boss: { name: "å±±è„ˆä¹‹ç‹", hp: 280, attack: 32, defense: 25, exp: 120, gold: 100, imageKey: "mountainKing", drops: [{itemId: 103, chance: 1}, {itemId: 202, chance: 0.5}] }, 
                    treasures: [2, 202, 301]
                },
                { 
                    name: "åœ°ç„ç«å±±", imageKey: "volcano", 
                    enemies: [ 
                        { name: "ç†”å²©ç¸", hp: 150, attack: 36, defense: 15, exp: 45, gold: 30, drops: [{itemId: 3, chance: 0.1}] },
                         { name: "ç«ç„°æƒ¡é­”", hp: 180, attack: 40, defense: 12, exp: 60, gold: 40, drops: [{itemId: 3, chance: 0.2}] }
                    ], 
                    boss: { name: "ç«ç„°é ˜ä¸»", hp: 500, attack: 45, defense: 25, exp: 200, gold: 180, imageKey: "fireLord", drops: [{itemId: 104, chance: 1}, {itemId: 203, chance: 1}] }, 
                    treasures: [3, 104, 203] 
                }
            ];

            const demonKing = { name: "æ¯€æ»…é­”ç‹", hp: 800, maxHp: 800, attack: 55, defense: 30, exp: 500, gold: 1000, imageKey: "demonKing", drops: [] };
            
            // --- LIFECYCLE & CORE LOGIC ---
            useEffect(() => {
                setImage('menu');
                setIsLoading(false);
            }, []);

            const getPlayerStats = useCallback(() => {
                if (!player) return {};
                const equipment = player.equipment;
                const baseAttack = player.baseAttack;
                const baseDefense = player.baseDefense;
                const baseSpeed = player.baseSpeed;

                const weaponAttack = equipment.weapon ? equipment.weapon.attack || 0 : 0;
                const armorDefense = equipment.armor ? equipment.armor.defense || 0 : 0;
                const accessorySpeed = equipment.accessory ? equipment.accessory.speed || 0 : 0;

                // è¨ˆç®—ç‹€æ…‹æ•ˆæœåŠ æˆ
                let attackMultiplier = 1;
                let defenseMultiplier = 1;
                let dodgeBonus = 0;

                player.statusEffects?.forEach(effect => {
                    if (effect.type === 'attack_boost') attackMultiplier *= effect.value;
                    if (effect.type === 'defense_boost') defenseMultiplier *= effect.value;
                    if (effect.type === 'dodge_boost') dodgeBonus += effect.value;
                });

                return {
                    attack: Math.floor((baseAttack + weaponAttack) * attackMultiplier),
                    defense: Math.floor((baseDefense + armorDefense) * defenseMultiplier),
                    speed: baseSpeed + accessorySpeed,
                    dodgeChance: Math.min(0.8, dodgeBonus),
                };
            }, [player]);

            const startGame = (name, className) => {
                const classData = classes[className];
                const initialPlayer = {
                    name,
                    class: className,
                    level: 1,
                    hp: 100 + (classData.bonuses.hp || 0),
                    maxHp: 100 + (classData.bonuses.hp || 0),
                    mp: 50 + (classData.bonuses.mp || 0),
                    maxMp: 50 + (classData.bonuses.mp || 0),
                    baseAttack: 20 + classData.bonuses.attack,
                    baseDefense: 10 + classData.bonuses.defense,
                    baseSpeed: 15 + classData.bonuses.speed,
                    luck: 10 + classData.bonuses.luck,
                    exp: 0,
                    gold: 100,
                    skillPoints: 1,
                    inventory: [{...itemDatabase[1], instanceId: Date.now()}],
                    equipment: { weapon: null, armor: null, accessory: null },
                    skills: Object.fromEntries(classData.skills.map(skill => [skill, skillDatabase[skill]])),
                    statusEffects: [],
                    stats: { 
                        enemiesDefeated: 0, 
                        treasuresFound: 0, 
                        goldEarned: 100, 
                        criticalHits: 0, 
                        bossesDefeated: 0,
                        skillsUsed: 0,
                        itemsUsed: 0,
                        totalDamageDealt: 0,
                        totalDamageTaken: 0
                    }
                };
                setPlayer(initialPlayer);
                setCurrentAreaIndex(0);
                setGameState('playing');
                setImage(areas[0].imageKey);
                addLog(`${classData.emoji} ${name} é¸æ“‡äº†${classData.name}è·æ¥­ï¼Œé–‹å§‹å†’éšªï¼`, "important");
            };
            
            const handlePlayerAction = useCallback((action) => {
                if (!isPlayerTurn || !battleState || !player) return;
                setIsPlayerTurn(false);

                let newPlayer = JSON.parse(JSON.stringify(player));
                let newBattleState = { ...battleState };
                const playerStats = getPlayerStats();
                let playerDamage = 0;
                let isCrit = false;

                // ç©å®¶è¡Œå‹•
                if (action.type === 'attack') {
                    isCrit = Math.random() < (player.luck / 200 + 0.05);
                    let baseDamage = Math.floor(playerStats.attack * (isCrit ? 1.5 : 1) * (0.8 + Math.random() * 0.4));
                    playerDamage = Math.max(1, baseDamage - (newBattleState.defense || 0));
                    addLog(`ä½ é€ æˆäº† ${playerDamage} é»å‚·å®³${isCrit ? 'ï¼æš´æ“Šï¼' : ''}`, 'attack');
                    addCombatAnimation(`-${playerDamage}`, isCrit ? 'critical' : 'damage');
                    
                    if (isCrit) {
                        newPlayer.stats.criticalHits++;
                    }
                    newPlayer.stats.totalDamageDealt += playerDamage;
                    
                } else if (action.type === 'skill') {
                    const skill = newPlayer.skills[action.skillName];
                    if (newPlayer.mp < skill.mp) {
                        addLog("MPä¸è¶³ï¼", "error");
                        setIsPlayerTurn(true);
                        return;
                    }
                    
                    newPlayer.mp -= skill.mp;
                    newPlayer.stats.skillsUsed++;
                    
                    if (skill.type === 'damage') {
                        isCrit = skill.critChance ? Math.random() < skill.critChance : false;
                        let baseDamage = Math.floor(playerStats.attack * skill.power * (isCrit ? 1.5 : 1));
                        playerDamage = Math.max(1, baseDamage - (newBattleState.defense || 0));
                        addLog(`ä½ ä½¿ç”¨ ${skill.name}ï¼Œé€ æˆ ${playerDamage} é»å‚·å®³${isCrit ? 'ï¼æš´æ“Šï¼' : ''}ï¼`, 'attack');
                        addCombatAnimation(`-${playerDamage}`, isCrit ? 'critical' : 'damage');
                        
                        if (isCrit) {
                            newPlayer.stats.criticalHits++;
                        }
                        newPlayer.stats.totalDamageDealt += playerDamage;
                        
                    } else if (skill.type === 'heal') {
                        const healAmount = Math.floor(newPlayer.maxHp * skill.power);
                        newPlayer.hp = Math.min(newPlayer.maxHp, newPlayer.hp + healAmount);
                        addLog(`ä½ ä½¿ç”¨ ${skill.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`, 'heal');
                        addCombatAnimation(`+${healAmount}`, 'heal');
                        
                    } else if (skill.type === 'buff') {
                        if (skill.effect) {
                            applyStatusEffect({
                                ...skill.effect,
                                name: skill.name,
                                icon: 'âœ¨'
                            });
                            addLog(`ä½ ä½¿ç”¨ ${skill.name}ï¼`, 'buff');
                        }
                        
                    } else if (skill.type === 'debuff') {
                        // æ‡‰ç”¨çµ¦æ•µäººçš„è² é¢æ•ˆæœ
                        if (skill.effect) {
                            newBattleState.statusEffects = newBattleState.statusEffects || [];
                            newBattleState.statusEffects.push({
                                ...skill.effect,
                                name: skill.name,
                                icon: 'ğŸ§ª'
                            });
                            addLog(`ä½ ä½¿ç”¨ ${skill.name}ï¼Œ${newBattleState.name}ä¸­æ¯’äº†ï¼`, 'debuff');
                        }
                    }
                    
                } else if (action.type === 'use_potion') {
                    const itemIndex = newPlayer.inventory.findIndex(i => i.instanceId === action.item.instanceId);
                    if (itemIndex > -1) {
                        const item = newPlayer.inventory[itemIndex];
                        if(item.heal) newPlayer.hp = Math.min(newPlayer.maxHp, newPlayer.hp + item.heal);
                        if(item.mp) newPlayer.mp = Math.min(newPlayer.maxMp, newPlayer.mp + item.mp);
                        newPlayer.inventory.splice(itemIndex, 1);
                        newPlayer.stats.itemsUsed++;
                        addLog(`ä½ ä½¿ç”¨äº† ${item.name}ï¼`, 'heal');
                    }
                }

                newBattleState.hp -= playerDamage;

                // å‹åˆ©åˆ¤æ–·
                if (newBattleState.hp <= 0) {
                    setTimeout(() => {
                        addLog(`ä½ æ“Šæ•—äº† ${newBattleState.name}ï¼`, "victory");
                        const expGained = newBattleState.exp;
                        const goldGained = newBattleState.gold;
                        newPlayer.exp += expGained;
                        newPlayer.gold += goldGained;
                        
                        // æ›´æ–°çµ±è¨ˆ
                        updatePlayerStats('enemiesDefeated');
                        updatePlayerStats('goldEarned', goldGained);
                        
                        if (newBattleState.name.includes('å®ˆè­·è€…') || newBattleState.name.includes('ç‹') || newBattleState.name.includes('é ˜ä¸»') || newBattleState.name === demonKing.name) {
                            updatePlayerStats('bossesDefeated');
                        }
                        
                        // æ‰è½ç‰©å“
                        if(newBattleState.drops){
                            newBattleState.drops.forEach(drop => {
                                if(Math.random() < drop.chance){
                                    const droppedItem = {...itemDatabase[drop.itemId], instanceId: Date.now() + Math.random()};
                                    newPlayer.inventory.push(droppedItem);
                                    addLog(`ä½ ç²å¾—äº† [${droppedItem.name}]ï¼`, 'treasure');
                                }
                            });
                        }

                        // å‡ç´šåˆ¤æ–·
                        const expToNextLevel = newPlayer.level * 100;
                        if (newPlayer.exp >= expToNextLevel) {
                            newPlayer.level++;
                            newPlayer.exp -= expToNextLevel;
                            newPlayer.skillPoints++;
                            newPlayer.maxHp += 20;
                            newPlayer.maxMp += 10;
                            newPlayer.hp = newPlayer.maxHp;
                            newPlayer.mp = newPlayer.maxMp;
                            newPlayer.baseAttack += 3;
                            newPlayer.baseDefense += 2;
                            addLog(`ç­‰ç´šæå‡ï¼ä½ ç¾åœ¨æ˜¯ ${newPlayer.level} ç´šï¼`, "level_up");
                            setImage('levelUp');
                        }
                        
                        // è™•ç†å›åˆçµæŸçš„ç‹€æ…‹æ•ˆæœ
                        processStatusEffects();
                        
                        setPlayer(newPlayer);
                        setBattleState(null);
                        setIsPlayerTurn(true);
                        
                        if(newBattleState.name === demonKing.name) {
                            setGameState('victory');
                            setImage('victory');
                        } else {
                           setImage(areas[currentAreaIndex].imageKey);
                        }
                    }, 500);
                    return;
                }
                
                setBattleState(newBattleState);
                setPlayer(newPlayer);

                // æ•µäººå›åˆ
                setTimeout(() => {
                    // è™•ç†æ•µäººçš„ç‹€æ…‹æ•ˆæœå‚·å®³
                    let poisonDamage = 0;
                    if (newBattleState.statusEffects) {
                        newBattleState.statusEffects.forEach(effect => {
                            if (effect.type === 'poison') {
                                poisonDamage += effect.damage;
                            }
                        });
                        
                        if (poisonDamage > 0) {
                            newBattleState.hp -= poisonDamage;
                            addLog(`${newBattleState.name} å—åˆ°æ¯’ç´ å‚·å®³ ${poisonDamage} é»ï¼`, 'poison');
                            addCombatAnimation(`-${poisonDamage}`, 'poison');
                        }
                        
                        // æ¸›å°‘ç‹€æ…‹æ•ˆæœæŒçºŒæ™‚é–“
                        newBattleState.statusEffects = newBattleState.statusEffects
                            .map(effect => ({ ...effect, duration: effect.duration - 1 }))
                            .filter(effect => effect.duration > 0);
                    }
                    
                    // æª¢æŸ¥æ•µäººæ˜¯å¦å› ç‚ºç‹€æ…‹æ•ˆæœæ­»äº¡
                    if (newBattleState.hp <= 0) {
                        setBattleState(null);
                        setIsPlayerTurn(true);
                        setImage(areas[currentAreaIndex].imageKey);
                        return;
                    }
                    
                    // æ•µäººæ”»æ“Š
                    const playerStats = getPlayerStats();
                    const dodged = Math.random() < playerStats.dodgeChance;
                    
                    if (dodged) {
                        addLog(`ä½ æˆåŠŸé–ƒé¿äº† ${newBattleState.name} çš„æ”»æ“Šï¼`, 'dodge');
                        addCombatAnimation('é–ƒé¿!', 'dodge');
                    } else {
                        let enemyDamage = Math.max(1, newBattleState.attack - playerStats.defense);
                        
                        // è­·ç›¾æ¸›å…
                        const shieldEffect = newPlayer.statusEffects.find(e => e.type === 'shield');
                        if (shieldEffect) {
                            const blockedDamage = Math.min(enemyDamage, shieldEffect.value);
                            enemyDamage -= blockedDamage;
                            shieldEffect.value -= blockedDamage;
                            
                            addLog(`è­·ç›¾å¸æ”¶äº† ${blockedDamage} é»å‚·å®³ï¼`, 'shield');
                            
                            if (shieldEffect.value <= 0) {
                                newPlayer.statusEffects = newPlayer.statusEffects.filter(e => e !== shieldEffect);
                            }
                        }
                        
                        addLog(`${newBattleState.name} æ”»æ“Šä½ ï¼Œé€ æˆ ${enemyDamage} é»å‚·å®³ï¼`, 'enemy_attack');
                        addCombatAnimation(`-${enemyDamage}`, 'enemy_damage');
                        
                        setPlayer(prev => {
                            const newHp = prev.hp - enemyDamage;
                            const updatedPlayer = {
                                ...prev,
                                hp: newHp,
                                stats: {
                                    ...prev.stats,
                                    totalDamageTaken: prev.stats.totalDamageTaken + enemyDamage
                                }
                            };
                            
                            if (newHp <= 0) {
                                setTimeout(() => {
                                    setGameState('gameOver');
                                    setImage('gameOver');
                                }, 1000);
                                return { ...updatedPlayer, hp: 0 };
                            }
                            return updatedPlayer;
                        });
                    }
                    
                    setBattleState(newBattleState);
                    processStatusEffects();
                    setIsPlayerTurn(true);
                }, 1200);

            }, [isPlayerTurn, battleState, player, getPlayerStats, addLog, addCombatAnimation, setImage, currentAreaIndex, applyStatusEffect, processStatusEffects, updatePlayerStats]);
            
            const explore = () => {
                const area = areas[currentAreaIndex];
                const eventRoll = Math.random();
                if (eventRoll < 0.6) { // é­é‡æ•µäºº
                    const enemyTemplate = area.enemies[Math.floor(Math.random() * area.enemies.length)];
                    const enemy = {...enemyTemplate, maxHp: enemyTemplate.hp, statusEffects: []};
                    setBattleState(enemy);
                    setImage(enemy.imageKey || 'combat');
                    addLog(`é­é‡ ${enemy.name}ï¼`, "encounter");
                } else if (eventRoll < 0.8) { // ç™¼ç¾å¯¶è—
                    const treasureId = area.treasures[Math.floor(Math.random() * area.treasures.length)];
                    const treasure = {...itemDatabase[treasureId], instanceId: Date.now()};
                    setPlayer(prev => ({ ...prev, inventory: [...prev.inventory, treasure] }));
                    updatePlayerStats('treasuresFound');
                    addLog(`ç™¼ç¾ ${treasure.name}ï¼`, "treasure");
                    setImage(treasure.imageKey || 'treasureFound');
                } else { // ç™¼ç¾é‡‘å¹£
                    const goldFound = Math.floor(Math.random() * 50) + 20;
                    setPlayer(prev => ({ ...prev, gold: prev.gold + goldFound }));
                    updatePlayerStats('goldEarned', goldFound);
                    addLog(`ç™¼ç¾ ${goldFound} é‡‘å¹£ï¼`, "gold");
                    setImage('goldCoins');
                }
            };

            const equipItem = (itemToEquip) => {
                setPlayer(prev => {
                    const newInventory = [...prev.inventory];
                    const itemIndex = newInventory.findIndex(i => i.instanceId === itemToEquip.instanceId);
                    if (itemIndex === -1) return prev; 

                    newInventory.splice(itemIndex, 1);

                    const newEquipment = { ...prev.equipment };
                    const currentItem = newEquipment[itemToEquip.type];

                    if (currentItem) {
                        newInventory.push(currentItem);
                    }

                    newEquipment[itemToEquip.type] = itemToEquip;
                    
                    addLog(`è£å‚™äº† ${itemToEquip.name}ã€‚`, 'system');
                    return { ...prev, inventory: newInventory, equipment: newEquipment };
                });
            };

            const useItem = (itemToUse) => {
                setPlayer(prev => {
                    const newInventory = [...prev.inventory];
                    const itemIndex = newInventory.findIndex(i => i.instanceId === itemToUse.instanceId);
                    if (itemIndex === -1) return prev;

                    const item = newInventory[itemIndex];
                    let newHp = prev.hp;
                    let newMp = prev.mp;

                    if (item.heal) newHp = Math.min(prev.maxHp, prev.hp + item.heal);
                    if (item.mp) newMp = Math.min(prev.maxMp, prev.mp + item.mp);
                    
                    newInventory.splice(itemIndex, 1);
                    addLog(`ä½¿ç”¨äº† ${item.name}ã€‚`, 'heal');
                    
                    return { 
                        ...prev, 
                        hp: newHp, 
                        mp: newMp, 
                        inventory: newInventory,
                        stats: {
                            ...prev.stats,
                            itemsUsed: prev.stats.itemsUsed + 1
                        }
                    };
                });
            };
            
            const sellItem = (itemToSell) => {
                setPlayer(prev => {
                    const newInventory = prev.inventory.filter(i => i.instanceId !== itemToSell.instanceId);
                    const newGold = prev.gold + itemToSell.value;
                    addLog(`è³£æ‰äº† ${itemToSell.name}ï¼Œç²å¾— ${itemToSell.value} é‡‘å¹£ã€‚`, 'gold');
                    return { 
                        ...prev, 
                        inventory: newInventory, 
                        gold: newGold,
                        stats: {
                            ...prev.stats,
                            goldEarned: prev.stats.goldEarned + itemToSell.value
                        }
                    };
                });
            };

            const learnSkill = (skillToLearn) => {
                setPlayer(prev => {
                    if (prev.skillPoints < 1) {
                        addLog("æŠ€èƒ½é»æ•¸ä¸è¶³ï¼", "error");
                        return prev;
                    }
                    if (prev.skills[skillToLearn.name]) {
                        addLog("ä½ å·²ç¶“å­¸æœƒé€™å€‹æŠ€èƒ½äº†ï¼", "error");
                        return prev;
                    }

                    const newSkills = {...prev.skills, [skillToLearn.name]: skillToLearn};
                    addLog(`å­¸æœƒäº†æ–°æŠ€èƒ½ï¼š${skillToLearn.name}ï¼`, 'level_up');
                    return { ...prev, skills: newSkills, skillPoints: prev.skillPoints - 1 };
                });
            };

            // --- RENDER COMPONENTS ---
            const ImageDisplay = () => (
                <div className="image-container">
                    {currentImage.imageUrl ? (
                        <img 
                            src={currentImage.imageUrl} 
                            alt="éŠæˆ²å ´æ™¯"
                            style={{ width: '100%', height: '100%', objectFit: 'cover' }}
                            className={battleState ? 'image-combat-shake' : 'image-gentle-transition'}
                        />
                    ) : (
                        <div className="image-placeholder"><div className="image-placeholder-icon">ğŸ–¼ï¸</div><div>åœ–ç‰‡è¼‰å…¥ä¸­...</div></div>
                    )}
                    {combatAnimations.map(anim => (
                        <div key={anim.id} className="combat-animation" style={{
                            left: `${Math.random() * 60 + 20}%`, 
                            top: `${Math.random() * 40 + 30}%`,
                            color: anim.type === 'critical' ? '#dc2626' : 
                                   anim.type === 'heal' ? '#22c55e' : 
                                   anim.type === 'poison' ? '#8b5cf6' :
                                   anim.type === 'dodge' ? '#06b6d4' : '#f97316'
                        }}>{anim.text}</div>
                    ))}
                </div>
            );

            const ProgressBar = ({ current, max, color, emoji }) => (
                <div className="progress-container">
                    <span style={{ fontSize: '0.8rem', minWidth: '40px' }}>{emoji}</span>
                    <div className="progress-bar"><div className="progress-fill" style={{ width: `${(current / max) * 100}%`, background: color }} /></div>
                    <span style={{ fontSize: '0.8rem', minWidth: '60px' }}>{Math.ceil(current)}/{max}</span>
                </div>
            );

            const StatusEffectsDisplay = ({ statusEffects }) => {
                if (!statusEffects || statusEffects.length === 0) return null;
                
                return (
                    <div className="status-effects">
                        {statusEffects.map((effect, index) => (
                            <div key={index} className="status-effect">
                                <span>{effect.icon || 'âœ¨'}</span>
                                <span>{effect.name}</span>
                                <span>({effect.duration})</span>
                            </div>
                        ))}
                    </div>
                );
            };

            // --- GAME STATE RENDER LOGIC ---
            if (gameState === 'menu') {
                return (
                    <div style={{ minHeight: '100vh', padding: '1rem', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <div style={{ maxWidth: '600px', width: '100%', textAlign: 'center' }}>
                            <h1 style={{ fontSize: '2.5rem', fontWeight: 'bold', marginBottom: '1rem', color: '#fbbf24' }}>âš”ï¸ å‹‡è€…å‚³èªª âš”ï¸</h1>
                            <h2 style={{ fontSize: '1.2rem', marginBottom: '2rem', color: '#60a5fa' }}>äº”åŸŸå¾é€” - å¢å¼·ç‰ˆ</h2>
                            <ImageDisplay />
                            <div className="game-card" style={{ padding: '1.5rem' }}>
                                <button onClick={() => setGameState('character_creation')} className="btn btn-primary" style={{ fontSize: '1.1rem', padding: '1rem 2rem', width: '100%' }}>ğŸš€ é–‹å§‹æ–°å†’éšª</button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'character_creation') {
                return (
                    <div style={{ minHeight: '100vh', padding: '1rem', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <div style={{ maxWidth: '600px', width: '100%', textAlign: 'center' }}>
                             <h1 style={{ fontSize: '2rem', fontWeight: 'bold', marginBottom: '1rem', color: '#fbbf24' }}>ğŸ‘¤ å‰µå»ºä½ çš„è‹±é›„</h1>
                             <ImageDisplay />
                             <div className="game-card" style={{ padding: '1.5rem' }}>
                                <input type="text" placeholder="è¼¸å…¥ä½ çš„è‹±é›„åå­—" value={name} onChange={(e) => setName(e.target.value)} style={{ width: '100%', padding: '0.75rem', borderRadius: '8px', border: '1px solid #4b5563', background: '#1f2937', color: 'white', marginBottom: '1rem' }} />
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    {Object.keys(classes).map(key => (
                                        <button key={key} onClick={() => setSelectedClass(key)} className={`btn ${selectedClass === key ? 'btn-success' : 'btn-secondary'}`} onMouseEnter={() => setImage(key)}>
                                            {classes[key].emoji} {classes[key].name}
                                        </button>
                                    ))}
                                </div>
                                {selectedClass && <p style={{fontSize: '0.8rem', color: '#d1d5db', marginBottom: '1rem'}}>{classes[selectedClass].description}</p>}
                                <button onClick={() => startGame(name, selectedClass)} disabled={!name || !selectedClass} className="btn btn-primary" style={{ width: '100%' }}>âœ”ï¸ ç¢ºèªå‰µå»º</button>
                             </div>
                        </div>
                    </div>
                );
            }
            
            if (gameState === 'victory' || gameState === 'gameOver') {
                const isVictory = gameState === 'victory';
                return (
                    <div style={{ minHeight: '100vh', padding: '1rem', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <div style={{ maxWidth: '600px', width: '100%', textAlign: 'center' }}>
                            <h1 style={{ fontSize: '2.5rem', fontWeight: 'bold', marginBottom: '1rem', color: isVictory ? '#fbbf24' : '#ef4444' }}>{isVictory ? 'ğŸ† å‚³èªªèª•ç”Ÿï¼' : 'ğŸ’€ è‹±é›„éš•è½'}</h1>
                            <ImageDisplay />
                            <div className="game-card" style={{ padding: '1.5rem' }}>
                                <p style={{ marginBottom: '1rem' }}>{isVictory ? `æ­å–œ ${player.name}ï¼Œä½ æ‹¯æ•‘äº†ä¸–ç•Œï¼` : 'ä½ çš„å†’éšªåˆ°æ­¤ç‚ºæ­¢...'}</p>
                                {player && (
                                    <div style={{ fontSize: '0.8rem', color: '#d1d5db', marginBottom: '1rem', textAlign: 'left' }}>
                                        <p>æœ€çµ‚ç­‰ç´š: {player.level}</p>
                                        <p>æ“Šæ•—æ•µäºº: {player.stats.enemiesDefeated}</p>
                                        <p>æ“Šæ•—é¦–é ˜: {player.stats.bossesDefeated}</p>
                                        <p>æš´æ“Šæ¬¡æ•¸: {player.stats.criticalHits}</p>
                                        <p>é€ æˆç¸½å‚·å®³: {player.stats.totalDamageDealt}</p>
                                        <p>æ‰¿å—ç¸½å‚·å®³: {player.stats.totalDamageTaken}</p>
                                    </div>
                                )}
                                <button onClick={() => window.location.reload()} className="btn btn-purple" style={{ width: '100%' }}>ğŸ”„ é‡æ–°é–‹å§‹</button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'playing' && player) {
                const playerStats = getPlayerStats();
                const currentArea = areas[currentAreaIndex];
                
                const availableSkillsToLearn = Object.values(skillDatabase).filter(skill => 
                    !player.skills[skill.name] && skill.unlockLevel && player.level >= skill.unlockLevel
                );

                return (
                    <div className="mobile-layout">
                        {/* é ‚éƒ¨ç‹€æ…‹æ¬„ */}
                        <div className="top-panel">
                            <div className="game-card" style={{ padding: '1rem' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                    <div style={{ fontSize: '1rem', fontWeight: 'bold', color: '#fbbf24' }}>{classes[player.class]?.emoji} {player.name}</div>
                                    <div style={{ fontSize: '0.8rem', color: '#9ca3af' }}>Lv.{player.level} | SP: {player.skillPoints}</div>
                                </div>
                                <ProgressBar emoji="â¤ï¸" current={player.hp} max={player.maxHp} color="linear-gradient(90deg, #dc2626, #ef4444)" />
                                <ProgressBar emoji="âš¡" current={player.mp} max={player.maxMp} color="linear-gradient(90deg, #2563eb, #3b82f6)" />
                                <ProgressBar emoji="â­" current={player.exp} max={player.level * 100} color="linear-gradient(90deg, #fbbf24, #f59e0b)" />
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '0.5rem', fontSize: '0.75rem', marginTop: '0.75rem', textAlign: 'center' }}>
                                    <div>âš”ï¸ {playerStats.attack}</div>
                                    <div>ğŸ›¡ï¸ {playerStats.defense}</div>
                                    <div>ğŸƒ {playerStats.speed}</div>
                                    <div>ğŸ’° {player.gold}</div>
                                </div>
                                <StatusEffectsDisplay statusEffects={player.statusEffects} />
                                <div className="equipment-visual" style={{ marginTop: '0.75rem' }}>
                                    <div className={`equipment-slot ${player.equipment.weapon ? 'equipped' : ''}`}><div className="equipment-slot-icon">âš”ï¸</div><div className="equipment-slot-name">{player.equipment.weapon?.name || 'æ­¦å™¨'}</div></div>
                                    <div className={`equipment-slot ${player.equipment.armor ? 'equipped' : ''}`}><div className="equipment-slot-icon">ğŸ›¡ï¸</div><div className="equipment-slot-name">{player.equipment.armor?.name || 'è­·ç”²'}</div></div>
                                    <div className={`equipment-slot ${player.equipment.accessory ? 'equipped' : ''}`}><div className="equipment-slot-icon">ğŸ’</div><div className="equipment-slot-name">{player.equipment.accessory?.name || 'é£¾å“'}</div></div>
                                </div>
                            </div>
                        </div>

                        {/* ä¸»éŠæˆ²å€åŸŸ */}
                        <div className="main-game-area game-card" style={{ padding: '1rem' }}>
                            <div className="game-content">
                                <div className="game-display">
                                    <ImageDisplay />
                                    {battleState ? (
                                        <div className="battle-container">
                                            <div className="battle-info">
                                                <div style={{ background: 'rgba(127, 29, 29, 0.7)', padding: '0.75rem', borderRadius: '0.75rem', marginBottom: '0.5rem' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                        <span style={{ fontWeight: 'bold' }}>{battleState.name}</span>
                                                        <span>{Math.ceil(battleState.hp)}/{battleState.maxHp}</span>
                                                    </div>
                                                    <ProgressBar current={battleState.hp} max={battleState.maxHp} color="#dc2626" emoji="ğŸ©¸" />
                                                    <StatusEffectsDisplay statusEffects={battleState.statusEffects} />
                                                </div>
                                            </div>
                                            <div className="battle-log compact-log">
                                                {gameLog.slice(0, 4).map((log, index) => (
                                                    <div key={index} className="log-entry" style={{ 
                                                        color: log.type === 'attack' ? '#fca5a5' : 
                                                               log.type === 'enemy_attack' ? '#fca5a5' : 
                                                               log.type === 'heal' ? '#86efac' : 
                                                               log.type === 'treasure' ? '#fbbf24' : 
                                                               log.type === 'buff' ? '#c084fc' :
                                                               log.type === 'debuff' ? '#f472b6' :
                                                               log.type === 'dodge' ? '#67e8f9' : '#d1d5db' 
                                                    }}>
                                                        {log.message}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ) : (
                                        <div>
                                            <h2 style={{ fontSize: '1.1rem', fontWeight: 'bold', color: '#10b6d4' }}>{currentArea.name}</h2>
                                            <div className="compact-log" style={{ marginTop: '1rem', height: '120px' }}>
                                                {gameLog.slice(0, 5).map((log, index) => <div key={index} className="log-entry" style={{color: log.type === 'treasure' ? '#fbbf24' : '#d1d5db' }}>{log.message}</div>)}
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                {/* å›ºå®šçš„è¡Œå‹•æŒ‰éˆ•å€åŸŸ */}
                                <div className="fixed-action-area">
                                    {battleState ? (
                                        <div className="quick-actions">
                                            <button onClick={() => handlePlayerAction({ type: 'attack' })} disabled={!isPlayerTurn} className="btn btn-primary quick-action-btn"><span>âš”ï¸</span><span>æ”»æ“Š</span></button>
                                            {Object.values(player.skills).map(skill => (
                                                <button key={skill.name} onClick={() => handlePlayerAction({ type: 'skill', skillName: skill.name })} disabled={!isPlayerTurn || player.mp < skill.mp} className="btn btn-purple quick-action-btn" title={skill.desc}><span>âœ¨</span><span>{skill.name}</span></button>
                                            ))}
                                            <button onClick={() => {
                                                const potion = player.inventory.find(i => i.type === 'potion');
                                                if (potion) useItem(potion);
                                            }} disabled={!isPlayerTurn || !player.inventory.some(i => i.type === 'potion')} className="btn btn-success quick-action-btn"><span>ğŸ§ª</span><span>è—¥æ°´</span></button>
                                        </div>
                                    ) : (
                                        <div className="quick-actions">
                                            <button onClick={explore} className="btn btn-success quick-action-btn"><span>ğŸ”</span><span>æ¢ç´¢</span></button>
                                            <button onClick={() => { 
                                                const boss = {...currentArea.boss}; 
                                                boss.maxHp = boss.hp; 
                                                boss.statusEffects = [];
                                                setBattleState(boss); 
                                                setImage(boss.imageKey || 'combat'); 
                                            }} className="btn btn-primary quick-action-btn"><span>ğŸ’€</span><span>æŒ‘æˆ°é¦–é ˜</span></button>
                                            {currentAreaIndex < areas.length - 1 ? (
                                                <button onClick={() => { 
                                                    setCurrentAreaIndex(i => i + 1); 
                                                    setImage(areas[currentAreaIndex + 1].imageKey); 
                                                }} className="btn btn-secondary quick-action-btn"><span>â¡ï¸</span><span>å‰å¾€ä¸‹ä¸€å€</span></button>
                                            ) : (
                                                <button onClick={() => { 
                                                    const finalBoss = {...demonKing, statusEffects: []};
                                                    setBattleState(finalBoss); 
                                                    setImage('demonKing'); 
                                                }} className="btn btn-primary quick-action-btn"><span>ğŸ”¥</span><span>æœ€çµ‚æ±ºæˆ°</span></button>
                                            )}
                                            {/* éæˆ°é¬¥ç‹€æ…‹ä¸‹ä¹Ÿå¯ä»¥ä½¿ç”¨æŠ€èƒ½å’Œç‰©å“ */}
                                            {Object.values(player.skills).filter(skill => skill.type === 'heal' || skill.type === 'buff').map(skill => (
                                                <button key={skill.name} onClick={() => {
                                                    if (skill.type === 'heal') {
                                                        if (player.mp >= skill.mp && player.hp < player.maxHp) {
                                                            const healAmount = Math.floor(player.maxHp * skill.power);
                                                            setPlayer(prev => ({
                                                                ...prev,
                                                                hp: Math.min(prev.maxHp, prev.hp + healAmount),
                                                                mp: prev.mp - skill.mp,
                                                                stats: { ...prev.stats, skillsUsed: prev.stats.skillsUsed + 1 }
                                                            }));
                                                            addLog(`ä½¿ç”¨ ${skill.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`, 'heal');
                                                        }
                                                    } else if (skill.type === 'buff') {
                                                        if (player.mp >= skill.mp) {
                                                            setPlayer(prev => ({
                                                                ...prev,
                                                                mp: prev.mp - skill.mp,
                                                                stats: { ...prev.stats, skillsUsed: prev.stats.skillsUsed + 1 }
                                                            }));
                                                            applyStatusEffect({
                                                                ...skill.effect,
                                                                name: skill.name,
                                                                icon: 'âœ¨'
                                                            });
                                                            addLog(`ä½¿ç”¨ ${skill.name}ï¼`, 'buff');
                                                        }
                                                    }
                                                }} disabled={player.mp < skill.mp || (skill.type === 'heal' && player.hp >= player.maxHp)} className="btn btn-purple quick-action-btn" title={skill.desc}><span>âœ¨</span><span>{skill.name}</span></button>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* åº•éƒ¨é¢æ¿ */}
                        <div className="bottom-panel">
                            <div className="game-card">
                                <div className="tab-bar">
                                    <div onClick={() => setActiveTab('inventory')} className={`tab-button ${activeTab === 'inventory' ? 'active' : ''}`}>ğŸ’ èƒŒåŒ…</div>
                                    <div onClick={() => setActiveTab('skills')} className={`tab-button ${activeTab === 'skills' ? 'active' : ''}`}>ğŸŒŸ æŠ€èƒ½</div>
                                    <div onClick={() => setActiveTab('stats')} className={`tab-button ${activeTab === 'stats' ? 'active' : ''}`}>ğŸ“Š ç‹€æ…‹</div>
                                </div>
                                <div className="tab-content">
                                    {activeTab === 'inventory' && (
                                        <div>
                                            {player.inventory.length === 0 ? <p style={{textAlign: 'center', color: '#9ca3af'}}>èƒŒåŒ…æ˜¯ç©ºçš„</p> : player.inventory.map(item => (
                                                <div key={item.instanceId} className="inventory-item">
                                                    <div className="item-info">
                                                        <div className="item-name">{item.name}</div>
                                                        <div className="item-stats">
                                                            {item.attack && `æ”»æ“Š+${item.attack} `}
                                                            {item.defense && `é˜²ç¦¦+${item.defense} `}
                                                            {item.speed && `é€Ÿåº¦+${item.speed} `}
                                                            {item.heal && `æ¢å¾©${item.heal}HP `}
                                                            {item.mp && `æ¢å¾©${item.mp}MP `}
                                                            åƒ¹å€¼: {item.value}é‡‘
                                                        </div>
                                                    </div>
                                                    <div className="item-actions">
                                                        {['weapon', 'armor', 'accessory'].includes(item.type) && <button onClick={() => equipItem(item)} className="btn btn-success">è£å‚™</button>}
                                                        {item.type === 'potion' && <button onClick={() => useItem(item)} className="btn btn-success">ä½¿ç”¨</button>}
                                                        <button onClick={() => sellItem(item)} className="btn btn-warning">å‡ºå”®</button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    {activeTab === 'skills' && (
                                        <div>
                                            <p style={{textAlign: 'center', color: '#9ca3af', marginBottom: '0.5rem'}}>æŠ€èƒ½é»æ•¸: {player.skillPoints}</p>
                                            {availableSkillsToLearn.map(skill => (
                                                 <div key={skill.name} className="skill-item">
                                                    <div className="skill-info">
                                                        <div className="skill-name" style={{color: '#22c55e'}}>{skill.name} â­æ–°æŠ€èƒ½!</div>
                                                        <div className="skill-desc">{skill.desc}</div>
                                                    </div>
                                                    <div className="skill-actions">
                                                        <button onClick={() => learnSkill(skill)} disabled={player.skillPoints < 1} className="btn btn-success">å­¸ç¿’</button>
                                                    </div>
                                                </div>
                                            ))}
                                            {Object.values(player.skills).map(skill => (
                                                <div key={skill.name} className="skill-item" style={{opacity: 0.8}}>
                                                    <div className="skill-info">
                                                        <div className="skill-name">{skill.name} âœ“å·²å­¸æœƒ</div>
                                                        <div className="skill-desc">{skill.desc} (æ¶ˆè€— {skill.mp} MP)</div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    {activeTab === 'stats' && (
                                        <div style={{fontSize: '0.8rem', color: '#d1d5db'}}>
                                            <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.5rem'}}>
                                                <div>
                                                    <p>ç­‰ç´š: {player.level}</p>
                                                    <p>ç¶“é©—å€¼: {player.exp}/{player.level * 100}</p>
                                                    <p>æŠ€èƒ½é»æ•¸: {player.skillPoints}</p>
                                                    <p>é‡‘å¹£: {player.gold}</p>
                                                </div>
                                                <div>
                                                    <p>æ“Šæ•—æ•µäºº: {player.stats.enemiesDefeated}</p>
                                                    <p>æ“Šæ•—é¦–é ˜: {player.stats.bossesDefeated}</p>
                                                    <p>ç™¼ç¾å¯¶è—: {player.stats.treasuresFound}</p>
                                                    <p>æš´æ“Šæ¬¡æ•¸: {player.stats.criticalHits}</p>
                                                </div>
                                            </div>
                                            <div style={{marginTop: '0.5rem', paddingTop: '0.5rem', borderTop: '1px solid rgba(255,255,255,0.1)'}}>
                                                <p>æŠ€èƒ½ä½¿ç”¨æ¬¡æ•¸: {player.stats.skillsUsed}</p>
                                                <p>é“å…·ä½¿ç”¨æ¬¡æ•¸: {player.stats.itemsUsed}</p>
                                                <p>é€ æˆç¸½å‚·å®³: {player.stats.totalDamageDealt}</p>
                                                <p>æ‰¿å—ç¸½å‚·å®³: {player.stats.totalDamageTaken}</p>
                                                <p>ç¸½ç²å¾—é‡‘å¹£: {player.stats.goldEarned}</p>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            return <div style={{display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100vh'}}>è¼‰å…¥ä¸­æˆ–ç™¼ç”ŸéŒ¯èª¤...</div>;
        };

        ReactDOM.render(<AdventureGame />, document.getElementById('root'));
    </script>
</body>
</html>