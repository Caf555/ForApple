<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>氣眼之弈 - 網路功能修正版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
            touch-action: manipulation;
        }
        .wood-bg {
            background-color: #d2b48c;
            background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
        }
        .panel {
            background-color: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .btn:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .btn:disabled {
            cursor: not-allowed;
            background-color: #9ca3af;
        }
        canvas {
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border-radius: 12px;
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal-backdrop.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 90%;
            width: 400px;
        }
        .input-field {
            border: 2px solid #ccc;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            width: 100%;
            text-align: center;
            font-size: 1.1rem;
            letter-spacing: 2px;
        }
        .thinking-indicator {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
          0%, 100% {
            opacity: 1;
          }
          50% {
            opacity: .5;
          }
        }
    </style>
</head>
<body class="wood-bg bg-gray-100 flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <div id="game-container" class="w-full max-w-3xl mx-auto hidden">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-gray-800 mb-2">氣眼之弈</h1>
        <p id="game-mode-display" class="text-center text-gray-600 mb-4"></p>

        <!-- 遊戲狀態面板 -->
        <div id="status-panel" class="panel grid grid-cols-3 gap-2 sm:gap-4 p-3 sm:p-4 rounded-xl mb-4 text-center">
            <div id="black-score-panel" class="p-2 rounded-lg">
                <h3 class="text-base sm:text-lg font-bold">黑方 <span id="black-player-label"></span></h3>
                <div class="flex items-center justify-center space-x-2">
                    <div class="w-5 h-5 bg-black rounded-full"></div>
                    <p id="black-score" class="text-xl sm:text-2xl font-mono">地: 0</p>
                </div>
                 <p id="black-captures" class="text-xs sm:text-sm text-gray-600">提子: 0</p>
            </div>
            <div id="game-info-panel" class="flex flex-col items-center justify-center p-2 rounded-lg">
                <h3 id="turn-indicator" class="text-lg sm:text-xl font-bold text-gray-800 mb-1">輪到 黑方</h3>
                <p id="game-message" class="text-sm text-red-600 font-semibold h-5"></p>
            </div>
            <div id="white-score-panel" class="p-2 rounded-lg">
                <h3 class="text-base sm:text-lg font-bold">白方 <span id="white-player-label"></span></h3>
                <div class="flex items-center justify-center space-x-2">
                    <div class="w-5 h-5 bg-white border border-gray-400 rounded-full"></div>
                    <p id="white-score" class="text-xl sm:text-2xl font-mono">地: 0</p>
                </div>
                 <p id="white-captures" class="text-xs sm:text-sm text-gray-600">提子: 0</p>
            </div>
        </div>

        <!-- 棋盤畫布 -->
        <div class="relative w-full" style="padding-bottom: 100%;">
            <canvas id="go-board" class="absolute top-0 left-0 w-full h-full bg-[#e3c16f] rounded-xl"></canvas>
        </div>

        <!-- 網路對戰資訊 -->
        <div id="network-info" class="panel mt-4 p-3 rounded-xl text-center hidden">
            <p class="text-gray-700">你的玩家ID: <strong id="user-id-display" class="select-all"></strong></p>
            <p class="text-gray-700">房間ID: <strong id="game-id-display" class="select-all">點擊複製</strong></p>
        </div>

        <!-- 控制按鈕 -->
        <div class="flex justify-center space-x-4 mt-4">
            <button id="pass-btn" class="btn bg-blue-500 text-white font-bold py-2 px-6 rounded-lg shadow-md">虛手</button>
            <button id="resign-btn" class="btn bg-yellow-500 text-white font-bold py-2 px-6 rounded-lg shadow-md">認輸</button>
            <button id="scoring-btn" class="btn bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-md hidden">完成數地</button>
            <button id="main-menu-btn" class="btn bg-red-500 text-white font-bold py-2 px-6 rounded-lg shadow-md">主選單</button>
        </div>
    </div>

    <!-- 遊戲模式選擇彈窗 -->
    <div id="main-menu-modal" class="modal-backdrop visible">
        <div class="modal-content panel">
            <h2 class="text-3xl font-bold mb-6 text-gray-800">選擇遊戲模式</h2>
            <div class="space-y-4">
                <button data-mode="vs-computer" class="btn mode-select-btn w-full bg-green-500 text-white py-3 rounded-lg text-lg">單人對戰 (MCTS AI)</button>
                <button data-mode="local-2p" class="btn mode-select-btn w-full bg-purple-500 text-white py-3 rounded-lg text-lg">雙人對戰 (本機)</button>
                <button data-mode="network-2p" id="network-2p-btn" class="btn mode-select-btn w-full bg-indigo-500 text-white py-3 rounded-lg text-lg">雙人對戰 (網路)</button>
            </div>
        </div>
    </div>

    <!-- 棋盤尺寸選擇彈窗 -->
    <div id="size-selection-modal" class="modal-backdrop">
        <div class="modal-content panel">
            <h2 class="text-3xl font-bold mb-6 text-gray-800">選擇棋盤尺寸</h2>
            <div class="space-y-4">
                <button data-size="9" class="btn size-select-btn w-full bg-orange-500 text-white py-3 rounded-lg text-lg">9 路棋盤 (快速對局)</button>
                <button data-size="19" class="btn size-select-btn w-full bg-sky-500 text-white py-3 rounded-lg text-lg">19 路棋盤 (標準)</button>
            </div>
             <button id="back-to-main-from-size-btn" class="btn w-full bg-gray-400 text-white py-2 rounded-lg mt-6">返回</button>
        </div>
    </div>

    <!-- 網路對戰設定彈窗 -->
    <div id="network-setup-modal" class="modal-backdrop">
        <div class="modal-content panel">
            <h2 class="text-3xl font-bold mb-6 text-gray-800">網路對戰</h2>
            <div class="space-y-4">
                <button id="create-game-btn" class="btn w-full bg-blue-500 text-white py-3 rounded-lg text-lg">創建新房間</button>
                <div>
                    <p class="mb-2 text-gray-600">或輸入房間ID加入</p>
                    <input type="text" id="join-game-id-input" class="input-field" placeholder="貼上房間ID">
                    <button id="join-game-btn" class="btn w-full bg-teal-500 text-white py-3 rounded-lg text-lg mt-2">加入房間</button>
                </div>
                 <button id="back-to-size-from-net-btn" class="btn w-full bg-gray-400 text-white py-2 rounded-lg mt-4">返回</button>
            </div>
        </div>
    </div>

    <!-- 計分方式選擇彈窗 -->
    <div id="scoring-choice-modal" class="modal-backdrop">
        <div class="modal-content panel">
            <h2 class="text-2xl font-bold mb-4">對局結束</h2>
            <p class="text-gray-600 mb-6">請選擇計分方式</p>
            <div class="space-y-4">
                <button id="auto-score-btn" class="btn w-full bg-cyan-500 text-white py-3 rounded-lg text-lg">自動判斷勝負</button>
                <button id="manual-score-btn" class="btn w-full bg-lime-600 text-white py-3 rounded-lg text-lg">手動數地</button>
            </div>
        </div>
    </div>
    
    <!-- 認輸確認彈窗 -->
    <div id="resign-confirm-modal" class="modal-backdrop">
        <div class="modal-content panel">
            <h2 class="text-2xl font-bold mb-4">確認認輸？</h2>
            <p class="text-gray-600 mb-6">認輸後，此局將判為您落敗。</p>
            <div class="flex justify-center space-x-4">
                <button id="confirm-resign-btn" class="btn bg-red-600 text-white py-2 px-8 rounded-lg">確認</button>
                <button id="cancel-resign-btn" class="btn bg-gray-400 text-white py-2 px-8 rounded-lg">取消</button>
            </div>
        </div>
    </div>

    <!-- 遊戲結束彈窗 -->
    <div id="game-over-modal" class="modal-backdrop">
        <div class="modal-content panel">
            <h2 id="winner-message" class="text-2xl sm:text-3xl font-bold mb-4"></h2>
            <p id="final-score" class="text-base sm:text-lg mb-6"></p>
            <button id="play-again-btn" class="btn bg-green-500 text-white font-bold py-2 px-8 rounded-lg">返回主選單</button>
        </div>
    </div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    let auth, db, app, userId, gameUnsubscribe = null;
    let firebaseAvailable = false;

    async function initFirebase() {
        try {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'go-game-default';
            const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
            const firebaseConfig = JSON.parse(firebaseConfigStr);
            
            if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey) {
                console.warn("Firebase config is empty or invalid. Network mode will be disabled.");
                firebaseAvailable = false;
                return false;
            }

            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            await new Promise((resolve, reject) => {
                const unsubscribe = onAuthStateChanged(auth, async (user) => {
                    unsubscribe(); // Unsubscribe after first auth state change
                    if (user) {
                        userId = user.uid;
                        resolve(userId);
                    } else {
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } else {
                                await signInAnonymously(auth);
                            }
                            userId = auth.currentUser.uid;
                            resolve(userId);
                        } catch (error) {
                            reject(error);
                        }
                    }
                }, reject);
            });

            firebaseAvailable = true;
            return true;
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            firebaseAvailable = false;
            return false;
        }
    }
    
    class MCTSNode {
        constructor(gameState, parent = null, move = null) {
            this.gameState = gameState; this.parent = parent; this.move = move;
            this.children = []; this.wins = 0; this.visits = 0;
            this.unexploredMoves = this.gameState.getValidMoves();
            for (let i = this.unexploredMoves.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.unexploredMoves[i], this.unexploredMoves[j]] = [this.unexploredMoves[j], this.unexploredMoves[i]];
            }
        }
        selectChild() {
            const C = Math.sqrt(2); let bestChild = null, bestScore = -Infinity;
            for (const child of this.children) {
                if (child.visits === 0) return child;
                const uct = (child.wins / child.visits) + C * Math.sqrt(Math.log(this.visits) / child.visits);
                if (uct > bestScore) { bestScore = uct; bestChild = child; }
            }
            return bestChild;
        }
        expand() {
            if (this.unexploredMoves.length === 0) return null;
            const move = this.unexploredMoves.pop();
            const nextGameState = this.gameState.clone(); nextGameState.applyMove(move);
            const childNode = new MCTSNode(nextGameState, this, move);
            this.children.push(childNode); return childNode;
        }
        update(result) { this.visits++; this.wins += result; }
    }
    class MCTS {
        constructor(gameState, iterations = 1000, timeLimit = 3000) { this.root = new MCTSNode(gameState); this.iterations = iterations; this.timeLimit = timeLimit; }
        runSearch() {
            const startTime = Date.now();
            for (let i = 0; i < this.iterations; i++) {
                if (Date.now() - startTime > this.timeLimit) break;
                let node = this.root;
                while (node.unexploredMoves.length === 0 && node.children.length > 0) node = node.selectChild();
                if (node.unexploredMoves.length > 0) node = node.expand();
                if (node) { const result = this.simulate(node.gameState); this.backpropagate(node, result); }
            }
        }
        simulate(gameState) {
            const simState = gameState.clone(); let passes = 0, turnLimit = (simState.size * simState.size);
            while (passes < 2 && turnLimit > 0) {
                const move = simState.getHeuristicMove();
                if (move === 'pass') { simState.applyMove('pass'); passes++; } 
                else { simState.applyMove(move); passes = 0; }
                turnLimit--;
            }
            const winner = simState.getWinner(); const originalPlayer = this.root.gameState.player;
            if (winner === originalPlayer) return 1; if (winner === 0) return 0.5; return 0;
        }
        backpropagate(node, result) { let tempNode = node; while (tempNode !== null) { tempNode.update(result); result = 1 - result; tempNode = tempNode.parent; } }
        getBestMove() { let bestChild = null, maxVisits = -1; for (const child of this.root.children) { if (child.visits > maxVisits) { maxVisits = child.visits; bestChild = child; } } return bestChild ? bestChild.move : 'pass'; }
    }

class GoGame {
    constructor(size = 19) {
        this.canvas = document.getElementById('go-board'); this.ctx = this.canvas.getContext('2d');
        this.size = size; this.gameContainer = document.getElementById('game-container');
        this.mainMenuModal = document.getElementById('main-menu-modal');
        this.sizeSelectionModal = document.getElementById('size-selection-modal');
        this.networkSetupModal = document.getElementById('network-setup-modal');
        this.gameOverModal = document.getElementById('game-over-modal');
        this.resignConfirmModal = document.getElementById('resign-confirm-modal');
        this.scoringChoiceModal = document.getElementById('scoring-choice-modal');
        this.turnIndicator = document.getElementById('turn-indicator');
        this.gameMessage = document.getElementById('game-message');
        this.blackScoreEl = document.getElementById('black-score');
        this.whiteScoreEl = document.getElementById('white-score');
        this.blackCapturesEl = document.getElementById('black-captures');
        this.whiteCapturesEl = document.getElementById('white-captures');
        this.blackPlayerLabel = document.getElementById('black-player-label');
        this.whitePlayerLabel = document.getElementById('white-player-label');
        this.gameModeDisplay = document.getElementById('game-mode-display');
        this.networkInfo = document.getElementById('network-info');
        this.userIdDisplay = document.getElementById('user-id-display');
        this.gameIdDisplay = document.getElementById('game-id-display');
        this.passBtn = document.getElementById('pass-btn');
        this.resignBtn = document.getElementById('resign-btn');
        this.scoringBtn = document.getElementById('scoring-btn');
        this.playAgainBtn = document.getElementById('play-again-btn');
        this.winnerMessage = document.getElementById('winner-message');
        this.finalScore = document.getElementById('final-score');
        this.selectedMode = null; this.gameMode = null;
        this.networkGameId = null; this.playerRole = null;
        this.initEventListeners();
    }

    initEventListeners() {
        document.querySelectorAll('.mode-select-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                this.selectedMode = e.target.dataset.mode;
                if (this.selectedMode === 'network-2p' && !firebaseAvailable) { 
                    this.setMessage("網路功能無法使用 (未設定Firebase)", "error"); 
                    return; 
                }
                this.mainMenuModal.classList.remove('visible');
                this.sizeSelectionModal.classList.add('visible');
            });
        });
        document.querySelectorAll('.size-select-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const size = parseInt(e.target.dataset.size);
                if (this.selectedMode === 'network-2p') {
                    this.sizeSelectionModal.classList.remove('visible');
                    this.networkSetupModal.classList.add('visible');
                    this.selectedSize = size;
                } else { this.startGame(this.selectedMode, size); }
            });
        });
        document.getElementById('back-to-main-from-size-btn').addEventListener('click', () => { this.sizeSelectionModal.classList.remove('visible'); this.mainMenuModal.classList.add('visible'); });
        document.getElementById('back-to-size-from-net-btn').addEventListener('click', () => { this.networkSetupModal.classList.remove('visible'); this.sizeSelectionModal.classList.add('visible'); });
        document.getElementById('main-menu-btn').addEventListener('click', () => this.goBackToMainMenu());
        document.getElementById('create-game-btn').addEventListener('click', () => this.createNetworkGame());
        document.getElementById('join-game-btn').addEventListener('click', () => this.joinNetworkGame());
        document.getElementById('auto-score-btn').addEventListener('click', () => this.enterAutoScoring());
        document.getElementById('manual-score-btn').addEventListener('click', () => this.enterManualScoring());
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));
        this.canvas.addEventListener('click', this.handleClick.bind(this));
        this.passBtn.addEventListener('click', this.handlePass.bind(this));
        this.resignBtn.addEventListener('click', () => this.resignConfirmModal.classList.add('visible'));
        document.getElementById('cancel-resign-btn').addEventListener('click', () => this.resignConfirmModal.classList.remove('visible'));
        document.getElementById('confirm-resign-btn').addEventListener('click', () => this.resignGame());
        this.scoringBtn.addEventListener('click', () => this.finalizeScore());
        this.playAgainBtn.addEventListener('click', () => { this.gameOverModal.classList.remove('visible'); this.goBackToMainMenu(); });
        
        // *** FIX: Replace navigator.clipboard.writeText with a fallback ***
        this.gameIdDisplay.addEventListener('click', () => {
            if (this.networkGameId) {
                const textArea = document.createElement("textarea");
                textArea.value = this.networkGameId;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        this.setMessage("房間ID已複製!", "info");
                    } else {
                        this.setMessage("複製失敗", "error");
                    }
                } catch (err) {
                    console.error('Fallback: Unable to copy', err);
                    this.setMessage("複製失敗", "error");
                }
                document.body.removeChild(textArea);
            }
        });

        window.addEventListener('resize', this.resizeCanvas.bind(this));
    }

    goBackToMainMenu() {
        this.gameContainer.classList.add('hidden');
        this.mainMenuModal.classList.add('visible');
        if (gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
        this.resetGame(this.size);
    }

    startGame(mode, size) {
        this.gameMode = mode; this.size = size;
        this.mainMenuModal.classList.remove('visible');
        this.sizeSelectionModal.classList.remove('visible');
        this.networkSetupModal.classList.remove('visible');
        this.gameContainer.classList.remove('hidden');
        this.resetGame(size); this.updatePlayerLabels(); this.resizeCanvas();
    }

    resetGame(size) {
        this.size = size; this.board = Array(size).fill(0).map(() => Array(size).fill(0));
        this.currentPlayer = 1; this.history = []; this.captures = { 1: 0, 2: 0 };
        this.passCount = 0; this.gameOver = false; this.isScoringPhase = false;
        this.deadGroups = new Set(); this.hoverPos = null; this.lastMove = null;
        this.territoryMap = Array(size).fill(0).map(() => Array(size).fill(0));
        if (this.gameMode !== 'network-2p') { this.networkGameId = null; this.playerRole = null; }
        this.passBtn.classList.remove('hidden'); this.resignBtn.classList.remove('hidden');
        this.scoringBtn.classList.add('hidden');
        this.gameMessage.textContent = '';
        this.updateUI();
    }
    
    updatePlayerLabels() {
        this.blackPlayerLabel.textContent = ''; this.whitePlayerLabel.textContent = '';
        this.networkInfo.classList.add('hidden');
        this.gameModeDisplay.textContent = `${this.size}路棋盤 - `;
        switch(this.gameMode) {
            case 'vs-computer': this.gameModeDisplay.textContent += '單人對戰 (MCTS AI)'; this.blackPlayerLabel.textContent = '(您)'; this.whitePlayerLabel.textContent = '(電腦)'; break;
            case 'local-2p': this.gameModeDisplay.textContent += '雙人對戰 (本機)'; break;
            case 'network-2p': this.gameModeDisplay.textContent += '雙人對戰 (網路)'; this.networkInfo.classList.remove('hidden'); if (this.playerRole === 'black') this.blackPlayerLabel.textContent = '(您)'; else if (this.playerRole === 'white') this.whitePlayerLabel.textContent = '(您)'; break;
        }
    }

    async createNetworkGame() {
        if (!userId) { this.setMessage("錯誤：無法取得玩家ID", "error"); return; }
        const size = this.selectedSize;
        const initialBoard = Array(size).fill(0).map(() => Array(size).fill(0));
        const gameId = doc(collection(db, "temp")).id.substring(0, 6).toUpperCase();
        this.networkGameId = gameId; this.playerRole = 'black';
        const initialGameState = { size, board: this.getBoardString(initialBoard), currentPlayer: 1, captures: { 1: 0, 2: 0 }, passCount: 0, gameOver: false, isScoringPhase: false, deadGroups: [], lastMove: null, players: { black: userId, white: null }, createdAt: serverTimestamp() };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'go-game-default';
        const gameRef = doc(db, `artifacts/${appId}/public/data/go-games`, gameId);
        try {
            await setDoc(gameRef, initialGameState);
            this.listenToGameUpdates(gameId); this.startGame('network-2p', size);
            this.gameIdDisplay.textContent = gameId; this.setMessage("房間已創建！分享ID給朋友", "info");
        } catch (error) { console.error("創建房間失敗:", error); this.setMessage("創建房間失敗", "error"); }
    }
    async joinNetworkGame() {
        const gameId = document.getElementById('join-game-id-input').value.toUpperCase();
        if (!gameId) { this.setMessage("請輸入房間ID", "error"); return; }
        if (!userId) { this.setMessage("錯誤：無法取得玩家ID", "error"); return; }
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'go-game-default';
        const gameRef = doc(db, `artifacts/${appId}/public/data/go-games`, gameId);
        try {
            const gameDoc = await getDoc(gameRef);
            if (!gameDoc.exists()) { this.setMessage("房間不存在", "error"); return; }
            const gameData = gameDoc.data();
            if (gameData.players.white && gameData.players.white !== userId) { this.setMessage("房間已滿", "error"); return; }
            await updateDoc(gameRef, { 'players.white': userId });
            this.networkGameId = gameId; this.playerRole = 'white';
            this.listenToGameUpdates(gameId); this.startGame('network-2p', gameData.size);
            this.gameIdDisplay.textContent = gameId;
        } catch (error) { console.error("加入房間失敗:", error); this.setMessage("加入房間失敗", "error"); }
    }
    listenToGameUpdates(gameId) {
        if (gameUnsubscribe) gameUnsubscribe();
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'go-game-default';
        const gameRef = doc(db, `artifacts/${appId}/public/data/go-games`, gameId);
        gameUnsubscribe = onSnapshot(gameRef, (doc) => {
            if (!doc.exists()) { this.setMessage("對手已離開，遊戲結束", "error"); this.goBackToMainMenu(); return; }
            const gameData = doc.data();
            if(this.size !== gameData.size) this.resetGame(gameData.size);
            this.board = this.parseBoardString(gameData.board);
            this.currentPlayer = gameData.currentPlayer;
            this.captures = gameData.captures;
            this.passCount = gameData.passCount;
            this.lastMove = gameData.lastMove;
            this.deadGroups = new Set(gameData.deadGroups || []);
            if (gameData.isScoringPhase && !this.isScoringPhase) this.enterManualScoring(); else this.isScoringPhase = gameData.isScoringPhase;
            if (gameData.showScoringChoice) this.showScoringChoice();
            if (gameData.gameOver && !this.gameOver) {
                if(gameData.resignedPlayer) this.endGameByResignation(gameData.resignedPlayer);
                else this.endGame(gameData.finalScores);
            } else { this.gameOver = gameData.gameOver; }
            this.updateUI(); this.draw();
        });
    }
    async updateNetworkGame(extraState = {}) {
        if (this.gameMode !== 'network-2p' || !this.networkGameId) return;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'go-game-default';
        const gameRef = doc(db, `artifacts/${appId}/public/data/go-games`, this.networkGameId);
        const gameState = { board: this.getBoardString(), currentPlayer: this.currentPlayer, captures: this.captures, passCount: this.passCount, gameOver: this.gameOver, lastMove: this.lastMove, isScoringPhase: this.isScoringPhase, deadGroups: Array.from(this.deadGroups), ...extraState };
        try { await updateDoc(gameRef, gameState); } 
        catch (error) { console.error("更新遊戲狀態失敗:", error); this.setMessage("網路同步錯誤", "error"); }
    }

    isMyTurn() {
        if (this.gameOver || this.isScoringPhase) return false;
        switch(this.gameMode) {
            case 'vs-computer': return this.currentPlayer === 1;
            case 'local-2p': return true;
            case 'network-2p': return (this.playerRole === 'black' && this.currentPlayer === 1) || (this.playerRole === 'white' && this.currentPlayer === 2);
            default: return false;
        }
    }
    handleClick(e) {
        const rect = this.canvas.getBoundingClientRect(), scaleX = this.canvas.width / rect.width, scaleY = this.canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX, mouseY = (e.clientY - rect.top) * scaleY;
        const x = Math.round((mouseX - this.boardPadding) / this.cellSize), y = Math.round((mouseY - this.boardPadding) / this.cellSize);
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) return;
        if (this.isScoringPhase) { this.toggleDeadGroup(x, y); return; }
        if (!this.isMyTurn()) { if (this.gameMode === 'network-2p' && !this.gameOver) { this.setMessage("等待對手落子...", "info"); } return; }
        if (this.hoverPos) { this.placeStone(this.hoverPos.x, this.hoverPos.y); }
    }
    handlePass() {
        if (!this.isMyTurn()) return;
        this.passCount++; this.lastMove = 'pass';
        this.setMessage(`${this.currentPlayer === 1 ? '黑方' : '白方'} 虛手`);
        if (this.passCount >= 2) { this.showScoringChoice(); return; }
        this.currentPlayer = 3 - this.currentPlayer;
        if (this.gameMode === 'network-2p') { this.updateNetworkGame(); } 
        else { this.updateUI(); this.draw(); if (this.gameMode === 'vs-computer' && this.currentPlayer === 2) this.computerMove(); }
    }
    placeStone(x, y) {
        if (!this.isValidMove(x, y, this.currentPlayer)) return;
        const tempBoard = this.board.map(row => row.slice()); tempBoard[y][x] = this.currentPlayer;
        const opponent = 3 - this.currentPlayer; let capturedStones = 0;
        this.getNeighbors(x, y).forEach(({nx, ny}) => {
            if (tempBoard[ny][nx] === opponent) {
                const { group } = this.getGroupAndLiberties(nx, ny, tempBoard);
                if (this.getGroupAndLiberties(nx, ny, tempBoard).liberties.size === 0) {
                    group.forEach(({gx, gy}) => { tempBoard[gy][gx] = 0; capturedStones++; });
                }
            }
        });
        this.board = tempBoard; this.captures[this.currentPlayer] += capturedStones;
        this.passCount = 0; this.lastMove = {x, y}; this.history.push(this.getBoardString());
        this.currentPlayer = 3 - this.currentPlayer;
        if (this.gameMode === 'network-2p') { this.updateNetworkGame(); } 
        else { this.updateUI(); this.draw(); if (this.gameMode === 'vs-computer' && this.currentPlayer === 2) this.computerMove(); }
    }
    
    resignGame() {
        this.resignConfirmModal.classList.remove('visible');
        if(this.gameMode === 'network-2p') {
            const resignedPlayer = this.playerRole === 'black' ? 1 : 2;
            this.updateNetworkGame({ gameOver: true, resignedPlayer });
        } else {
            this.endGameByResignation(this.currentPlayer);
        }
    }
    showScoringChoice() {
        this.passBtn.classList.add('hidden');
        this.resignBtn.classList.add('hidden');
        this.scoringChoiceModal.classList.add('visible');
        if (this.gameMode === 'network-2p') this.updateNetworkGame({ showScoringChoice: true });
    }
    enterManualScoring() {
        this.scoringChoiceModal.classList.remove('visible');
        this.isScoringPhase = true;
        this.scoringBtn.classList.remove('hidden');
        this.setMessage('請點擊標記死子，完成後按「完成數地」', 'info', true);
        if (this.gameMode === 'network-2p') this.updateNetworkGame({ isScoringPhase: true, showScoringChoice: false });
        this.draw();
    }
    enterAutoScoring() {
        this.scoringChoiceModal.classList.remove('visible');
        this.setMessage('電腦自動數地中...', 'info', true);
        setTimeout(() => {
            this.deadGroups = this.identifyDeadStones();
            this.finalizeScore();
        }, 100);
    }
    toggleDeadGroup(x, y) {
        if (this.board[y][x] === 0) return;
        const groupKey = this.getGroupKey(x, y);
        if (this.deadGroups.has(groupKey)) this.deadGroups.delete(groupKey);
        else this.deadGroups.add(groupKey);
        if (this.gameMode === 'network-2p') this.updateNetworkGame();
        this.draw();
    }
    finalizeScore() {
        this.gameMessage.textContent = '';
        const finalCaptures = { 1: this.captures[1], 2: this.captures[2] };
        const finalBoard = this.board.map(r => r.slice());
        this.deadGroups.forEach(groupKey => {
            const stones = groupKey.split(';').map(s => s.split(',').map(Number));
            const player = this.board[stones[0][1]][stones[0][0]];
            const opponent = 3 - player;
            finalCaptures[opponent] += stones.length;
            stones.forEach(([x, y]) => finalBoard[y][x] = 0);
        });
        const territory = this.calculateTerritory(true, finalBoard);
        const komi = this.size === 19 ? 6.5 : (this.size === 9 ? 3.5 : 0);
        const scores = { black: territory.blackTerritory + finalCaptures[1], white: territory.whiteTerritory + finalCaptures[2] + komi };
        this.endGame(scores);
    }

    computerMove() {
        if (this.gameOver) return;
        this.setMessage("電腦思考中...", "info", true);
        this.turnIndicator.classList.add('thinking-indicator');
        setTimeout(() => {
            const gameState = new GameStateForMCTS(this.board, this.currentPlayer, this.history);
            const validMoves = gameState.getValidMoves();
            if (validMoves.length === 0) { this.turnIndicator.classList.remove('thinking-indicator'); this.handlePass(); return; }
            const scoreDiff = gameState.getWinner(true);
            const resignThreshold = -(this.size * this.size * 0.25);
            if (this.history.length > this.size * this.size * 0.4 && scoreDiff < resignThreshold) {
                this.turnIndicator.classList.remove('thinking-indicator'); this.endGameByResignation(this.currentPlayer);
                return;
            }
            const mcts = new MCTS(gameState, this.size === 9 ? 2000 : 1500, this.size === 9 ? 4000 : 3000);
            mcts.runSearch();
            const bestMove = mcts.getBestMove();
            this.turnIndicator.classList.remove('thinking-indicator');
            this.gameMessage.textContent = '';
            if (bestMove === 'pass' || !bestMove) this.handlePass();
            else this.placeStone(bestMove.x, bestMove.y);
        }, 100);
    }
    
    endGame(finalScores) {
        if (this.gameOver) return; this.gameOver = true;
        let winnerText = '';
        if (finalScores.black > finalScores.white) winnerText = `黑方勝 ${ (finalScores.black - finalScores.white).toFixed(1) } 目`;
        else winnerText = `白方勝 ${ (finalScores.white - finalScores.black).toFixed(1) } 目`;
        this.winnerMessage.textContent = winnerText;
        this.finalScore.textContent = `最終比分 黑: ${finalScores.black.toFixed(1)} | 白: ${finalScores.white.toFixed(1)}`;
        this.gameOverModal.classList.add('visible');
        this.passBtn.classList.add('hidden'); this.resignBtn.classList.add('hidden'); this.scoringBtn.classList.add('hidden');
        this.draw();
        if (this.gameMode === 'network-2p' && this.playerRole === 'black') {
            this.updateNetworkGame({ gameOver: true, finalScores, isScoringPhase: false, showScoringChoice: false });
        }
    }
    endGameByResignation(resignedPlayer) {
        if (this.gameOver) return; this.gameOver = true;
        const winner = 3 - resignedPlayer;
        this.winnerMessage.textContent = `${winner === 1 ? '黑方' : '白方'} 勝`;
        this.finalScore.textContent = `${resignedPlayer === 1 ? '黑方' : '白方'} 認輸`;
        this.gameOverModal.classList.add('visible');
        this.passBtn.classList.add('hidden'); this.resignBtn.classList.add('hidden'); this.scoringBtn.classList.add('hidden');
        this.draw();
    }
    
    identifyDeadStones() {
        const deadGroups = new Set();
        const territory = this.calculateTerritory(true, this.board);
        const territoryMap = this.territoryMap;
        const visited = new Set();
        for (let y = 0; y < this.size; y++) {
            for (let x = 0; x < this.size; x++) {
                if (this.board[y][x] !== 0 && !visited.has(`${x},${y}`)) {
                    const { group, liberties } = this.getGroupAndLiberties(x, y);
                    group.forEach(stone => visited.add(`${stone.gx},${stone.gy}`));
                    let isDead = false;
                    const groupPlayer = this.board[y][x];
                    const opponentTerritory = groupPlayer === 1 ? 2 : 1;
                    const groupBorders = new Set();
                    group.forEach(stone => {
                        this.getNeighbors(stone.gx, stone.gy).forEach(n => {
                            if (this.board[n.ny][n.nx] === 0) {
                                groupBorders.add(territoryMap[n.ny][n.nx]);
                            }
                        });
                    });
                    if (groupBorders.size === 1 && groupBorders.has(opponentTerritory)) {
                        if (liberties.size <= 2) {
                            isDead = true;
                        }
                    }
                    if (isDead) {
                        deadGroups.add(this.getGroupKey(x, y));
                    }
                }
            }
        }
        return deadGroups;
    }

    resizeCanvas() { if (!this.gameContainer.classList.contains('hidden')) { const c = this.canvas.parentElement, s = Math.min(c.clientWidth, c.clientHeight); this.canvas.width = s; this.canvas.height = s; this.cellSize = s / (this.size + 1); this.boardPadding = this.cellSize; this.stoneRadius = this.cellSize * 0.47; this.draw(); } }
    draw() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.calculateTerritory(false, this.board); this.drawBoard(); this.drawStones(); if (this.hoverPos && (this.isMyTurn() || this.isScoringPhase)) this.drawHoverEffect(this.hoverPos.x, this.hoverPos.y); }
    drawBoard() { this.ctx.strokeStyle = '#5c4033'; this.ctx.lineWidth = Math.max(1, this.cellSize / 20); for (let i = 0; i < this.size; i++) { const p = this.boardPadding + i * this.cellSize; this.ctx.beginPath(); this.ctx.moveTo(this.boardPadding, p); this.ctx.lineTo(this.canvas.width - this.boardPadding, p); this.ctx.stroke(); this.ctx.beginPath(); this.ctx.moveTo(p, this.boardPadding); this.ctx.lineTo(p, this.canvas.height - this.boardPadding); this.ctx.stroke(); } const sP9 = [[2, 2], [6, 2], [4, 4], [2, 6], [6, 6]], sP19 = [[3, 3], [3, 9], [3, 15],[9, 3], [9, 9], [9, 15],[15, 3], [15, 9], [15, 15]]; const sP = this.size === 9 ? sP9 : sP19; this.ctx.fillStyle = '#5c4033'; sP.forEach(([x, y]) => { this.ctx.beginPath(); const cX = this.boardPadding + x * this.cellSize, cY = this.boardPadding + y * this.cellSize; this.ctx.arc(cX, cY, this.stoneRadius * 0.15, 0, 2 * Math.PI); this.ctx.fill(); }); }
    drawTerritory() { for (let y = 0; y < this.size; y++) for (let x = 0; x < this.size; x++) if (this.territoryMap[y][x] !== 0) { const cX = this.boardPadding + x * this.cellSize, cY = this.boardPadding + y * this.cellSize; this.ctx.fillStyle = this.territoryMap[y][x] === 1 ? 'rgba(80, 80, 80, 0.25)' : 'rgba(255, 255, 255, 0.35)'; this.ctx.globalAlpha = 0.6; this.ctx.fillRect(cX - this.cellSize / 2, cY - this.cellSize / 2, this.cellSize, this.cellSize); this.ctx.globalAlpha = 1.0; } }
    drawStones() { const lC = new Map(); for (let y = 0; y < this.size; y++) for (let x = 0; x < this.size; x++) if (this.board[y][x] !== 0) { const gK = this.getGroupKey(x, y); let l; if (lC.has(gK)) l = lC.get(gK); else { const { liberties } = this.getGroupAndLiberties(x, y); l = liberties.size; lC.set(gK, l); } const cX = this.boardPadding + x * this.cellSize, cY = this.boardPadding + y * this.cellSize; if (l > 0 && !this.isScoringPhase) { const gC = l === 1 ? 'rgba(255, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)', g = this.ctx.createRadialGradient(cX, cY, this.stoneRadius * 0.5, cX, cY, this.stoneRadius * 1.5); g.addColorStop(0, gC); g.addColorStop(1, 'transparent'); this.ctx.fillStyle = g; this.ctx.fillRect(cX - this.stoneRadius * 2, cY - this.stoneRadius * 2, this.stoneRadius * 4, this.stoneRadius * 4); } this.ctx.beginPath(); this.ctx.arc(cX, cY, this.stoneRadius, 0, 2 * Math.PI); this.ctx.fillStyle = this.board[y][x] === 1 ? '#1a1a1a' : '#f0f0f0'; this.ctx.fill(); if (this.board[y][x] === 2) { this.ctx.strokeStyle = '#888'; this.ctx.lineWidth = 1; this.ctx.stroke(); } if (this.isScoringPhase && this.deadGroups.has(gK)) { this.ctx.strokeStyle = 'red'; this.ctx.lineWidth = 3; this.ctx.beginPath(); this.ctx.moveTo(cX - this.stoneRadius * 0.6, cY - this.stoneRadius * 0.6); this.ctx.lineTo(cX + this.stoneRadius * 0.6, cY + this.stoneRadius * 0.6); this.ctx.moveTo(cX + this.stoneRadius * 0.6, cY - this.stoneRadius * 0.6); this.ctx.lineTo(cX - this.stoneRadius * 0.6, cY + this.stoneRadius * 0.6); this.ctx.stroke(); } } }
    drawHoverEffect(x, y) { if (this.board[y][x] !== 0) { const { group: g, liberties: l } = this.getGroupAndLiberties(x, y); this.ctx.strokeStyle = 'rgba(70, 130, 180, 0.8)'; this.ctx.lineWidth = Math.max(1.5, this.cellSize / 15); this.ctx.font = `bold ${this.cellSize * 0.6}px sans-serif`; this.ctx.fillStyle = 'rgba(70, 130, 180, 1)'; const gC = this.getGroupCenter(g), tX = this.boardPadding + gC.x * this.cellSize, tY = this.boardPadding + gC.y * this.cellSize; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; if (!this.isScoringPhase) this.ctx.fillText(l.size, tX, tY); l.forEach(lib => { const [lX, lY] = lib.split(',').map(Number), sS = this.findClosestStoneInGroup(g, lX, lY), sX = this.boardPadding + sS.x * this.cellSize, sY = this.boardPadding + sS.y * this.cellSize, eX = this.boardPadding + lX * this.cellSize, eY = this.boardPadding + lY * this.cellSize; if (!this.isScoringPhase) { this.ctx.beginPath(); this.ctx.moveTo(sX, sY); this.ctx.lineTo(eX, eY); this.ctx.stroke(); } }); } else if (this.isValidMove(x, y, this.currentPlayer)) { const cX = this.boardPadding + x * this.cellSize, cY = this.boardPadding + y * this.cellSize; this.ctx.globalAlpha = 0.6; this.ctx.beginPath(); this.ctx.arc(cX, cY, this.stoneRadius, 0, 2 * Math.PI); this.ctx.fillStyle = this.currentPlayer === 1 ? '#1a1a1a' : '#f0f0f0'; this.ctx.fill(); this.ctx.globalAlpha = 1.0; } }
    handleMouseMove(e) { if (!this.isMyTurn() && !this.isScoringPhase) { this.hoverPos = null; this.draw(); return; } const r = this.canvas.getBoundingClientRect(), sX = this.canvas.width / r.width, sY = this.canvas.height / r.height, mX = (e.clientX - r.left) * sX, mY = (e.clientY - r.top) * sY, x = Math.round((mX - this.boardPadding) / this.cellSize), y = Math.round((mY - this.boardPadding) / this.cellSize); if (x >= 0 && x < this.size && y >= 0 && y < this.size) { if (!this.hoverPos || this.hoverPos.x !== x || this.hoverPos.y !== y) { this.hoverPos = { x, y }; this.draw(); } } else { this.handleMouseLeave(); } }
    handleMouseLeave() { if (this.hoverPos) { this.hoverPos = null; this.draw(); } }
    isValidMove(x, y, player, board = this.board, history = this.history) { if (x < 0 || x >= this.size || y < 0 || y >= this.size || board[y][x] !== 0) return false; const tB = board.map(r => r.slice()); tB[y][x] = player; const o = 3 - player; let cC = false; this.getNeighbors(x, y).forEach(({nx, ny}) => { if (tB[ny][nx] === o && this.getGroupAndLiberties(nx, ny, tB).liberties.size === 0) cC = true; }); if (!cC && this.getGroupAndLiberties(x, y, tB).liberties.size === 0) { if (this.gameMode === 'vs-computer' && player === 1) this.setMessage("無效著法：自殺點", "error"); return false; } const bAC = tB.map(r => r.slice()); this.getNeighbors(x, y).forEach(({nx, ny}) => { if (bAC[ny][nx] === o) { const { group: g, liberties: l } = this.getGroupAndLiberties(nx, ny, bAC); if (l.size === 0) g.forEach(({gx, gy}) => { bAC[gy][gx] = 0; }); } }); const nBS = this.getBoardString(bAC); if (history.includes(nBS)) { if (this.gameMode === 'vs-computer' && player === 1) this.setMessage("無效著法：劫", "error"); return false; } return true; }
    getNeighbors(x, y) { const n = []; if (x > 0) n.push({nx: x - 1, ny: y}); if (x < this.size - 1) n.push({nx: x + 1, ny: y}); if (y > 0) n.push({nx: x, ny: y - 1}); if (y < this.size - 1) n.push({nx: x, ny: y + 1}); return n; }
    getGroupAndLiberties(sX, sY, bS = this.board) { const p = bS[sY][sX]; if (p === 0) return { group: [], liberties: new Set() }; const g = [], l = new Set(), v = new Set(), q = [{x: sX, y: sY}]; v.add(`${sX},${sY}`); while (q.length > 0) { const { x, y } = q.shift(); g.push({ gx: x, gy: y }); this.getNeighbors(x, y).forEach(({nx, ny}) => { const id = `${nx},${ny}`; if (v.has(id)) return; if (bS[ny][nx] === 0) l.add(id); else if (bS[ny][nx] === p) { v.add(id); q.push({x: nx, y: ny}); } }); } return { group: g, liberties: l }; }
    calculateTerritory(isFinal = false, board = this.board) { this.territoryMap = Array(this.size).fill(0).map(() => Array(this.size).fill(0)); const v = new Set(); let bT = 0, wT = 0; for (let y = 0; y < this.size; y++) for (let x = 0; x < this.size; x++) if (board[y][x] === 0 && !v.has(`${x},${y}`)) { const a = [], b = { black: false, white: false }, q = [{x, y}]; v.add(`${x},${y}`); while (q.length > 0) { const c = q.shift(); a.push(c); this.getNeighbors(c.x, c.y).forEach(n => { const id = `${n.nx},${n.ny}`; if (board[n.ny][n.nx] === 1) b.black = true; else if (board[n.ny][n.nx] === 2) b.white = true; else if (!v.has(id)) { v.add(id); q.push({x: n.nx, y: n.ny}); } }); } if (b.black && !b.white) { a.forEach(p => this.territoryMap[p.y][p.x] = 1); bT += a.length; } else if (!b.black && b.white) { a.forEach(p => this.territoryMap[p.y][p.x] = 2); wT += a.length; } } if(!isFinal) this.updateScores(bT, wT); return { blackTerritory: bT, whiteTerritory: wT }; }
    getScores() { let bT = 0, wT = 0; for (let y = 0; y < this.size; y++) for (let x = 0; x < this.size; x++) { if (this.territoryMap[y][x] === 1) bT++; if (this.territoryMap[y][x] === 2) wT++; } return { blackTerritory: bT, whiteTerritory: wT }; }
    updateUI() { this.turnIndicator.textContent = `輪到 ${this.currentPlayer === 1 ? '黑方' : '白方'}`; document.getElementById('black-score-panel').style.border = this.currentPlayer === 1 ? '2px solid #3b82f6' : 'none'; document.getElementById('white-score-panel').style.border = this.currentPlayer === 2 ? '2px solid #3b82f6' : 'none'; this.blackCapturesEl.textContent = `提子: ${this.captures[1]}`; this.whiteCapturesEl.textContent = `提子: ${this.captures[2]}`; this.updateScores(); this.updatePlayerLabels(); }
    updateScores(bT, wT) { const s = (bT === undefined) ? this.getScores() : {blackTerritory: bT, whiteTerritory: wT}; this.blackScoreEl.textContent = `地: ${s.blackTerritory}`; this.whiteScoreEl.textContent = `地: ${s.whiteTerritory}`; }
    setMessage(msg, type = "info", persistent = false) { this.gameMessage.textContent = msg; this.gameMessage.style.color = type === "error" ? '#dc2626' : '#16a34a'; if(!persistent) setTimeout(() => { if(this.gameMessage.textContent === msg) this.gameMessage.textContent = "" }, 3000); }
    getBoardString(board = this.board) { return board.map(r => r.join('')).join('-'); }
    parseBoardString(str) { return str.split('-').map(r => r.split('').map(Number)); }
    getGroupKey(x, y) { const { group: g } = this.getGroupAndLiberties(x, y); return g.map(p => `${p.gx},${p.gy}`).sort().join(';'); }
    getGroupCenter(g) { let sX = 0, sY = 0; g.forEach(({gx, gy}) => { sX += gx; sY += gy; }); return { x: sX / g.length, y: sY / g.length }; }
    findClosestStoneInGroup(g, tX, tY) { let cS = g[0], mD = Infinity; g.forEach(s => { const d = Math.hypot(s.gx - tX, s.gy - tY); if (d < mD) { mD = d; cS = s; } }); return {x: cS.gx, y: cS.gy}; }
}

class GameStateForMCTS {
    constructor(board, player, history) { this.board = board.map(r => r.slice()); this.player = player; this.history = [...history]; this.size = board.length; }
    clone() { return new GameStateForMCTS(this.board, this.player, this.history); }
    getNeighbors(x, y) { const n = []; if (x > 0) n.push({nx: x - 1, ny: y}); if (x < this.size - 1) n.push({nx: x + 1, ny: y}); if (y > 0) n.push({nx: x, ny: y - 1}); if (y < this.size - 1) n.push({nx: x, ny: y + 1}); return n; }
    getGroupAndLiberties(sX, sY, bS = this.board) { const p = bS[sY][sX]; if (p === 0) return { group: [], liberties: new Set() }; const g = [], l = new Set(), v = new Set(), q = [{x: sX, y: sY}]; v.add(`${sX},${sY}`); while (q.length > 0) { const { x, y } = q.shift(); g.push({ gx: x, gy: y }); this.getNeighbors(x, y).forEach(({nx, ny}) => { const id = `${nx},${ny}`; if (v.has(id)) return; if (bS[ny][nx] === 0) l.add(id); else if (bS[ny][nx] === p) { v.add(id); q.push({x: nx, y: ny}); } }); } return { group: g, liberties: l }; }
    getBoardString(board = this.board) { return board.map(r => r.join('')).join('-'); }
    isValidMove(x, y, player) { const board = this.board, history = this.history; if (x < 0 || x >= this.size || y < 0 || y >= this.size || board[y][x] !== 0) return false; const tB = board.map(r => r.slice()); tB[y][x] = player; const o = 3 - player; let cC = false; this.getNeighbors(x, y).forEach(({nx, ny}) => { if (tB[ny][nx] === o && this.getGroupAndLiberties(nx, ny, tB).liberties.size === 0) cC = true; }); if (!cC && this.getGroupAndLiberties(x, y, tB).liberties.size === 0) return false; const bAC = tB.map(r => r.slice()); this.getNeighbors(x, y).forEach(({nx, ny}) => { if (bAC[ny][nx] === o) { const { group: g, liberties: l } = this.getGroupAndLiberties(nx, ny, bAC); if (l.size === 0) g.forEach(({gx, gy}) => { bAC[gy][gx] = 0; }); } }); const nBS = this.getBoardString(bAC); if (history.includes(nBS)) return false; return true; }
    getValidMoves() { const m = []; for (let y = 0; y < this.size; y++) for (let x = 0; x < this.size; x++) if (this.isValidMove(x, y, this.player)) m.push({x, y}); return m; }
    getHeuristicMove() { const moves = this.getValidMoves(); if (moves.length === 0) return 'pass'; const opponent = 3 - this.player; let bestUrgentMove = null; let maxCapture = 0; for (const move of moves) { let capturedStones = 0; const tempBoard = this.board.map(r => r.slice()); tempBoard[move.y][move.x] = this.player; this.getNeighbors(move.x, move.y).forEach(({nx, ny}) => { if (tempBoard[ny][nx] === opponent) { const { group, liberties } = this.getGroupAndLiberties(nx, ny, tempBoard); if (liberties.size === 0) capturedStones += group.length; } }); if (capturedStones > maxCapture) { maxCapture = capturedStones; bestUrgentMove = move; } const myNeighbors = this.getNeighbors(move.x, move.y); for(const {nx, ny} of myNeighbors) { if(this.board[ny][nx] === this.player) { const { liberties } = this.getGroupAndLiberties(nx, ny, this.board); if(liberties.size === 1) { const { liberties: newLibs } = this.getGroupAndLiberties(nx, ny, tempBoard); if(newLibs.size > 1) return move; } } } } if (bestUrgentMove) return bestUrgentMove; const safeMoves = moves.filter(move => { const { liberties } = this.getGroupAndLiberties(move.x, move.y, this.board); if(liberties.size === 0){ const neighbors = this.getNeighbors(move.x, move.y); if(neighbors.every(({nx, ny}) => this.board[ny][nx] === this.player)) return false; } return true; }); const movePool = safeMoves.length > 0 ? safeMoves : moves; return movePool[Math.floor(Math.random() * movePool.length)]; }
    applyMove(move) { if (move === 'pass') { this.player = 3 - this.player; return; } const {x, y} = move; this.board[y][x] = this.player; const opponent = 3 - this.player; this.getNeighbors(x, y).forEach(({nx, ny}) => { if (this.board[ny][nx] === opponent) { const { group, liberties } = this.getGroupAndLiberties(nx, ny, this.board); if (liberties.size === 0) group.forEach(({gx, gy}) => { this.board[gy][gx] = 0; }); } }); this.history.push(this.getBoardString(this.board)); this.player = 3 - this.player; }
    isGameOver() { if (this.history.length < 2) return false; return this.history[this.history.length - 1].endsWith('pass') && this.history[this.history.length - 2].endsWith('pass'); }
    getWinner(returnScoreDiff = false) {
        let bS = 0, wS = 0, bC = 0, wC = 0; // Simplified captures for simulation
        const v = new Set();
        for (let y = 0; y < this.size; y++) {
            for (let x = 0; x < this.size; x++) {
                if(this.board[y][x] === 1) bS++;
                else if(this.board[y][x] === 2) wS++;
                else if (!v.has(`${x},${y}`)) {
                    const a = [], b = { black: false, white: false }, q = [{x, y}]; v.add(`${x},${y}`);
                    while (q.length > 0) { const c = q.shift(); a.push(c); this.getNeighbors(c.x, c.y).forEach(n => { const id = `${n.nx},${n.ny}`; if (this.board[n.ny][n.nx] === 1) b.black = true; else if (this.board[n.ny][n.nx] === 2) b.white = true; else if (!v.has(id)) { v.add(id); q.push({x: n.nx, y: n.ny}); } }); }
                    if (b.black && !b.white) bS += a.length;
                    else if (!b.black && b.white) wS += a.length;
                }
            }
        }
        const komi = this.size === 19 ? 6.5 : (this.size === 9 ? 3.5 : 0);
        const blackFinal = bS + bC;
        const whiteFinal = wS + wC + komi;
        if (returnScoreDiff) return this.player === 1 ? blackFinal - whiteFinal : whiteFinal - blackFinal;
        if (blackFinal > whiteFinal) return 1; if (whiteFinal > blackFinal) return 2; return 0;
    }
}

document.addEventListener('DOMContentLoaded', async () => {
    const firebaseReady = await initFirebase();
    if (!firebaseReady) {
        const networkBtn = document.getElementById('network-2p-btn');
        if (networkBtn) {
            networkBtn.disabled = true;
            networkBtn.textContent = '雙人對戰 (網路 - 無法使用)';
        }
    }
    new GoGame();
});

</script>

</body>
</html>
